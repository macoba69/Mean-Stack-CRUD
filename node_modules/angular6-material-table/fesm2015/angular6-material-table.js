import cloneDeep from 'lodash.clonedeep';
import { Injectable } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, Subject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class TableElement {
    /**
     * @param {?} init
     */
    constructor(init) {
        Object.assign(this, init);
        this.fillValidatorFromData();
        if (this.validator) {
            if (this.editing) {
                this.validator.enable();
            }
            else {
                this.validator.disable();
            }
        }
    }
    /**
     * @return {?}
     */
    get currentData() {
        //express hack
        if (this.validator) {
            return Object.assign(this._currentData, this.validator.getRawValue());
        }
        else {
            return this._currentData;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currentData(value) {
        this._currentData = value;
        this.fillValidatorFromData();
    }
    /**
     * @return {?}
     */
    fillValidatorFromData() {
        if (this.validator) {
            let /** @type {?} */ formData = {};
            for (let /** @type {?} */ key in this.validator.controls) {
                formData[key] = this._currentData[key];
            }
            this.validator.setValue(formData);
        }
    }
    /**
     * @return {?}
     */
    delete() {
        this.source.delete(this.id);
    }
    /**
     * @return {?}
     */
    confirmEditCreate() {
        this.originalData = undefined;
        if (this.id == -1)
            return this.source.confirmCreate(this);
        else
            return this.source.confirmEdit(this);
    }
    /**
     * @return {?}
     */
    startEdit() {
        this.originalData = cloneDeep(this.currentData);
        this.editing = true;
        this.validator.enable();
    }
    /**
     * @return {?}
     */
    cancelOrDelete() {
        if (this.id == -1 || !this.editing)
            this.delete();
        else {
            this.currentData = this.originalData;
            this.editing = false;
            this.validator.disable();
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DefaultValidatorService {
    /**
     * @return {?}
     */
    getRowValidator() {
        return new FormGroup({});
    }
}
DefaultValidatorService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class TableDataSource extends DataSource {
    /**
     * Creates a new TableDataSource instance, that can be used as datasource of `\@angular/cdk` data-table.
     * @param {?} data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
     * @param {?=} dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
     * @param {?=} validatorService Service that create instances of the FormGroup used to validate row fields.
     * @param {?=} config Additional configuration for table.
     */
    constructor(data, dataType, validatorService, config = { prependNewElements: false }) {
        super();
        this.validatorService = validatorService;
        this.config = config;
        if (!validatorService)
            this.validatorService = new DefaultValidatorService();
        if (dataType) {
            this.dataConstructor = dataType;
        }
        else {
            if (data && data.length > 0)
                this.dataKeys = Object.keys(data[0]);
            else
                throw new Error('You must define either a non empty array, or an associated class to build the table.');
        }
        this.rowsSubject = new BehaviorSubject(this.getRowsFromData(data));
        this.datasourceSubject = new Subject();
    }
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     * @return {?}
     */
    createNew() {
        const /** @type {?} */ source = this.rowsSubject.getValue();
        if (!this.existsNewElement(source)) {
            const /** @type {?} */ newElement = new TableElement({
                id: -1,
                editing: true,
                currentData: this.createNewObject(),
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
            if (this.config.prependNewElements) {
                this.rowsSubject.next([newElement].concat(source));
            }
            else {
                source.push(newElement);
                this.rowsSubject.next(source);
            }
        }
    }
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param {?} row Row to be confirmed.
     * @return {?}
     */
    confirmCreate(row) {
        if (!row.validator.valid) {
            return false;
        }
        const /** @type {?} */ source = this.rowsSubject.getValue();
        row.id = source.length - 1;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    }
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param {?} row Row to be edited.
     * @return {?}
     */
    confirmEdit(row) {
        if (!row.validator.valid) {
            return false;
        }
        const /** @type {?} */ source = this.rowsSubject.getValue();
        const /** @type {?} */ index = this.getIndexFromRowId(row.id, source);
        source[index] = row;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    }
    /**
     * Delete the row with the index specified.
     * @param {?} id
     * @return {?}
     */
    delete(id) {
        const /** @type {?} */ source = this.rowsSubject.getValue();
        const /** @type {?} */ index = this.getIndexFromRowId(id, source);
        source.splice(index, 1);
        this.updateRowIds(index, source);
        this.rowsSubject.next(source);
        if (id != -1)
            this.updateDatasourceFromRows(source);
    }
    /**
     * Get row from the table.
     * @param {?} id Id of the row to retrieve, -1 returns the current new line.
     * @return {?}
     */
    getRow(id) {
        const /** @type {?} */ source = this.rowsSubject.getValue();
        const /** @type {?} */ index = this.getIndexFromRowId(id, source);
        return (index >= 0 && index < source.length) ? source[index] : null;
    }
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param {?} data Data to update the table datasource.
     * @param {?=} options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     * @return {?}
     */
    updateDatasource(data, options = { emitEvent: true }) {
        if (this.currentData !== data) {
            this.currentData = data;
            this.rowsSubject.next(this.getRowsFromData(data));
            if (options.emitEvent)
                this.datasourceSubject.next(data);
        }
    }
    /**
     * Checks the existance of the a new row (not yet saved).
     * @param {?} source
     * @return {?}
     */
    existsNewElement(source) {
        return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
    }
    /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param {?} source
     * @return {?}
     */
    getNewRowIndex(source) {
        if (this.config.prependNewElements)
            return 0;
        else
            return source.length - 1;
    }
    /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param {?} index Index of the array.
     * @param {?} count Quantity of elements in the array.
     * @return {?}
     */
    getRowIdFromIndex(index, count) {
        if (this.config.prependNewElements)
            return count - 1 - index;
        else
            return index;
    }
    /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param {?} id
     * @param {?} source
     * @return {?}
     */
    getIndexFromRowId(id, source) {
        if (id == -1) {
            return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
        }
        else {
            if (this.config.prependNewElements)
                return source.length - 1 - id;
            else
                return id;
        }
    }
    /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param {?} initialIndex Initial index of source to be updated.
     * @param {?} source Array that contains the rows to be updated.
     * @return {?}
     */
    updateRowIds(initialIndex, source) {
        const /** @type {?} */ delta = this.config.prependNewElements ? -1 : 1;
        for (let /** @type {?} */ index = initialIndex; index < source.length && index >= 0; index += delta) {
            if (source[index].id != -1)
                source[index].id = this.getRowIdFromIndex(index, source.length);
        }
    }
    /**
     * Get the data from the rows.
     * @param {?} rows Rows to extract the data.
     * @return {?}
     */
    getDataFromRows(rows) {
        return rows
            .filter(row => row.id != -1)
            .map((row) => {
            return row.originalData ? row.originalData : row.currentData;
        });
    }
    /**
     * Update the datasource with the data contained in the specified rows.
     * @param {?} rows Rows that contains the datasource's new data.
     * @return {?}
     */
    updateDatasourceFromRows(rows) {
        this.currentData = this.getDataFromRows(rows);
        this.datasourceSubject.next(this.currentData);
    }
    /**
     * From an array of data, it returns rows containing the original data.
     * @param {?} arrayData Data from which create the rows.
     * @return {?}
     */
    getRowsFromData(arrayData) {
        return arrayData.map((data, index) => {
            return new TableElement({
                id: this.getRowIdFromIndex(index, arrayData.length),
                editing: false,
                currentData: data,
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
        });
    }
    /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     * @return {?}
     */
    createNewObject() {
        if (this.dataConstructor)
            return new this.dataConstructor();
        else {
            return this.dataKeys.reduce((obj, key) => {
                obj[key] = undefined;
                return obj;
            }, {});
        }
    }
    /**
     * Connect function called by the table to retrieve one stream containing
     *  the data to render.
     * @return {?}
     */
    connect() {
        return this.rowsSubject.asObservable();
    }
    /**
     * @return {?}
     */
    disconnect() { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
class ValidatorService {
}
ValidatorService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { TableDataSource, DefaultValidatorService, TableElement, ValidatorService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlL2xpYi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1lbGVtZW50LnRzIiwibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS9saWIvYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZGVmYXVsdC12YWxpZGF0b3Iuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUvbGliL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRhdGEtc291cmNlLnRzIiwibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS9saWIvYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtdmFsaWRhdG9yLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtGb3JtR3JvdXB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbmltcG9ydCB7VGFibGVEYXRhU291cmNlfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRhdGEtc291cmNlJztcclxuXHJcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XHJcblxyXG5leHBvcnQgY2xhc3MgVGFibGVFbGVtZW50PFQ+IHtcclxuICBpZDogbnVtYmVyO1xyXG4gIGVkaXRpbmc6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGE/OiBUO1xyXG4gIG9yaWdpbmFsRGF0YTogVDtcclxuICBzb3VyY2U6IFRhYmxlRGF0YVNvdXJjZTxUPjtcclxuICB2YWxpZGF0b3I6IEZvcm1Hcm91cDtcclxuICBnZXQgY3VycmVudERhdGEoKSB7XHJcbiAgICAvL2V4cHJlc3MgaGFja1xyXG4gICAgaWYgKHRoaXMudmFsaWRhdG9yKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMuX2N1cnJlbnREYXRhLCB0aGlzLnZhbGlkYXRvci5nZXRSYXdWYWx1ZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBjdXJyZW50RGF0YSh2YWx1ZSkge1xyXG4gICAgdGhpcy5fY3VycmVudERhdGEgPSB2YWx1ZTtcclxuICAgIHRoaXMuZmlsbFZhbGlkYXRvckZyb21EYXRhKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihpbml0OiBQYXJ0aWFsPFRhYmxlRWxlbWVudDxUPj4pIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdCk7XHJcbiAgICB0aGlzLmZpbGxWYWxpZGF0b3JGcm9tRGF0YSgpO1xyXG4gICAgaWYgKHRoaXMudmFsaWRhdG9yKSB7XHJcbiAgICAgIGlmICh0aGlzLmVkaXRpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvci5lbmFibGUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvci5kaXNhYmxlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZpbGxWYWxpZGF0b3JGcm9tRGF0YSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnZhbGlkYXRvcikge1xyXG4gICAgICBsZXQgZm9ybURhdGEgPSB7fTtcclxuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMudmFsaWRhdG9yLmNvbnRyb2xzKSB7XHJcbiAgICAgICAgZm9ybURhdGFba2V5XSA9IHRoaXMuX2N1cnJlbnREYXRhW2tleV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy52YWxpZGF0b3Iuc2V0VmFsdWUoZm9ybURhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVsZXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zb3VyY2UuZGVsZXRlKHRoaXMuaWQpO1xyXG4gIH1cclxuXHJcbiAgY29uZmlybUVkaXRDcmVhdGUoKTogYm9vbGVhbiB7XHJcbiAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHVuZGVmaW5lZDtcclxuICAgIGlmICh0aGlzLmlkID09IC0xKVxyXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY29uZmlybUNyZWF0ZSh0aGlzKTtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbmZpcm1FZGl0KHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRFZGl0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5vcmlnaW5hbERhdGEgPSBjbG9uZURlZXAodGhpcy5jdXJyZW50RGF0YSk7XHJcbiAgICB0aGlzLmVkaXRpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy52YWxpZGF0b3IuZW5hYmxlKCk7XHJcbiAgfVxyXG5cclxuICBjYW5jZWxPckRlbGV0ZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlkID09IC0xIHx8ICF0aGlzLmVkaXRpbmcpXHJcbiAgICAgIHRoaXMuZGVsZXRlKCk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IHRoaXMub3JpZ2luYWxEYXRhO1xyXG4gICAgICB0aGlzLmVkaXRpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy52YWxpZGF0b3IuZGlzYWJsZSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbmltcG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLXZhbGlkYXRvci5zZXJ2aWNlJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIERlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlIGltcGxlbWVudHMgVmFsaWRhdG9yU2VydmljZSB7XHJcblxyXG4gIGdldFJvd1ZhbGlkYXRvcigpOiBGb3JtR3JvdXAge1xyXG4gICAgcmV0dXJuIG5ldyBGb3JtR3JvdXAoe30pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge0RhdGFTb3VyY2V9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XHJcblxyXG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQge1RhYmxlRWxlbWVudH0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1lbGVtZW50JztcclxuaW1wb3J0IHtWYWxpZGF0b3JTZXJ2aWNlfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLXZhbGlkYXRvci5zZXJ2aWNlJztcclxuaW1wb3J0IHtEZWZhdWx0VmFsaWRhdG9yU2VydmljZX0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1kZWZhdWx0LXZhbGlkYXRvci5zZXJ2aWNlJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVGFibGVEYXRhU291cmNlPFQ+IGV4dGVuZHMgRGF0YVNvdXJjZTxUYWJsZUVsZW1lbnQ8VD4+IHtcclxuXHJcbiAgcHJpdmF0ZSByb3dzU3ViamVjdDogQmVoYXZpb3JTdWJqZWN0PFRhYmxlRWxlbWVudDxUPltdPjtcclxuICBkYXRhc291cmNlU3ViamVjdDogU3ViamVjdDxUW10+O1xyXG5cclxuICBwcml2YXRlIGRhdGFDb25zdHJ1Y3RvcjogbmV3ICgpID0+IFQ7XHJcbiAgcHJpdmF0ZSBkYXRhS2V5czogYW55W107XHJcblxyXG4gIHByaXZhdGUgY3VycmVudERhdGE6IGFueTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBUYWJsZURhdGFTb3VyY2UgaW5zdGFuY2UsIHRoYXQgY2FuIGJlIHVzZWQgYXMgZGF0YXNvdXJjZSBvZiBgQGFuZ3VsYXIvY2RrYCBkYXRhLXRhYmxlLlxyXG4gICAqIEBwYXJhbSBkYXRhIEFycmF5IGNvbnRhaW5pbmcgdGhlIGluaXRpYWwgdmFsdWVzIGZvciB0aGUgVGFibGVEYXRhU291cmNlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGBkYXRhVHlwZWAgbXVzdCBiZSBzcGVjaWZpZWQuXHJcbiAgICogQHBhcmFtIGRhdGFUeXBlIFR5cGUgb2YgZGF0YSBjb250YWluZWQgYnkgdGhlIFRhYmxlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGBkYXRhYCB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50IG11c3QgYmUgc3BlY2lmaWVkLlxyXG4gICAqIEBwYXJhbSB2YWxpZGF0b3JTZXJ2aWNlIFNlcnZpY2UgdGhhdCBjcmVhdGUgaW5zdGFuY2VzIG9mIHRoZSBGb3JtR3JvdXAgdXNlZCB0byB2YWxpZGF0ZSByb3cgZmllbGRzLlxyXG4gICAqIEBwYXJhbSBjb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0YWJsZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGRhdGE6IFRbXSxcclxuICAgIGRhdGFUeXBlPzogbmV3ICgpID0+IFQsXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvclNlcnZpY2U/OiBWYWxpZGF0b3JTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBjb25maWcgPSB7IHByZXBlbmROZXdFbGVtZW50czogZmFsc2UgfSlcclxuICB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGlmICghdmFsaWRhdG9yU2VydmljZSlcclxuICAgICAgdGhpcy52YWxpZGF0b3JTZXJ2aWNlID0gbmV3IERlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlKCk7XHJcblxyXG4gICAgaWYgKGRhdGFUeXBlKSB7XHJcbiAgICAgIHRoaXMuZGF0YUNvbnN0cnVjdG9yID0gZGF0YVR5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApXHJcbiAgICAgICAgdGhpcy5kYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgZWl0aGVyIGEgbm9uIGVtcHR5IGFycmF5LCBvciBhbiBhc3NvY2lhdGVkIGNsYXNzIHRvIGJ1aWxkIHRoZSB0YWJsZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLmdldFJvd3NGcm9tRGF0YShkYXRhKSk7XHJcbiAgICB0aGlzLmRhdGFzb3VyY2VTdWJqZWN0ID0gbmV3IFN1YmplY3Q8VFtdPigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGNyZWF0aW9uIG9mIGEgbmV3IGVsZW1lbnQsIHB1c2hpbmcgYW4gZW1wdHktZGF0YSByb3cgaW4gdGhlIHRhYmxlLlxyXG4gICAqL1xyXG4gIGNyZWF0ZU5ldygpOiB2b2lkIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZXhpc3RzTmV3RWxlbWVudChzb3VyY2UpKSB7XHJcblxyXG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IFRhYmxlRWxlbWVudCh7XHJcbiAgICAgICAgaWQ6IC0xLFxyXG4gICAgICAgIGVkaXRpbmc6IHRydWUsXHJcbiAgICAgICAgY3VycmVudERhdGE6IHRoaXMuY3JlYXRlTmV3T2JqZWN0KCksXHJcbiAgICAgICAgc291cmNlOiB0aGlzLFxyXG4gICAgICAgIHZhbGlkYXRvcjogdGhpcy52YWxpZGF0b3JTZXJ2aWNlLmdldFJvd1ZhbGlkYXRvcigpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpIHtcclxuICAgICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoW25ld0VsZW1lbnRdLmNvbmNhdChzb3VyY2UpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzb3VyY2UucHVzaChuZXdFbGVtZW50KTtcclxuICAgICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlybSBjcmVhdGlvbiBvZiB0aGUgcm93LiBTYXZlIGNoYW5nZXMgYW5kIGRpc2FibGUgZWRpdGluZy5cclxuICAgKiBJZiB2YWxpZGF0aW9uIGFjdGl2ZSBhbmQgcm93IGRhdGEgaXMgaW52YWxpZCwgaXQgZG9lc24ndCBjb25maXJtIGNyZWF0aW9uIG5laXRoZXIgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIEBwYXJhbSByb3cgUm93IHRvIGJlIGNvbmZpcm1lZC5cclxuICAgKi9cclxuICBjb25maXJtQ3JlYXRlKHJvdzogVGFibGVFbGVtZW50PFQ+KTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXJvdy52YWxpZGF0b3IudmFsaWQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgcm93LmlkID0gc291cmNlLmxlbmd0aCAtIDE7XHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuXHJcbiAgICByb3cuZWRpdGluZyA9IGZhbHNlO1xyXG4gICAgcm93LnZhbGlkYXRvci5kaXNhYmxlKCk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVEYXRhc291cmNlRnJvbVJvd3Moc291cmNlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlybSBlZGl0aW9uIG9mIHRoZSByb3cuIFNhdmUgY2hhbmdlcyBhbmQgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIElmIHZhbGlkYXRpb24gYWN0aXZlIGFuZCByb3cgZGF0YSBpcyBpbnZhbGlkLCBpdCBkb2Vzbid0IGNvbmZpcm0gZWRpdGluZyBuZWl0aGVyIGRpc2FibGUgZWRpdGluZy5cclxuICAgKiBAcGFyYW0gcm93IFJvdyB0byBiZSBlZGl0ZWQuXHJcbiAgICovXHJcbiAgY29uZmlybUVkaXQocm93OiBUYWJsZUVsZW1lbnQ8VD4pOiBib29sZWFuIHtcclxuICAgIGlmICghcm93LnZhbGlkYXRvci52YWxpZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4RnJvbVJvd0lkKHJvdy5pZCwgc291cmNlKTtcclxuXHJcbiAgICBzb3VyY2VbaW5kZXhdID0gcm93O1xyXG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XHJcblxyXG4gICAgcm93LmVkaXRpbmcgPSBmYWxzZTtcclxuICAgIHJvdy52YWxpZGF0b3IuZGlzYWJsZSgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRGF0YXNvdXJjZUZyb21Sb3dzKHNvdXJjZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSB0aGUgcm93IHdpdGggdGhlIGluZGV4IHNwZWNpZmllZC5cclxuICAgKi9cclxuICBkZWxldGUoaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4RnJvbVJvd0lkKGlkLCBzb3VyY2UpO1xyXG5cclxuICAgIHNvdXJjZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgdGhpcy51cGRhdGVSb3dJZHMoaW5kZXgsIHNvdXJjZSk7XHJcblxyXG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XHJcblxyXG4gICAgaWYgKGlkICE9IC0xKVxyXG4gICAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAqIEdldCByb3cgZnJvbSB0aGUgdGFibGUuXHJcbiAqIEBwYXJhbSBpZCBJZCBvZiB0aGUgcm93IHRvIHJldHJpZXZlLCAtMSByZXR1cm5zIHRoZSBjdXJyZW50IG5ldyBsaW5lLlxyXG4gKi9cclxuICBnZXRSb3coaWQ6IG51bWJlcik6IFRhYmxlRWxlbWVudDxUPiB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQoaWQsIHNvdXJjZSk7XHJcblxyXG4gICAgcmV0dXJuIChpbmRleCA+PSAwICYmIGluZGV4IDwgc291cmNlLmxlbmd0aCkgPyBzb3VyY2VbaW5kZXhdIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZGF0YXNvdXJjZSB3aXRoIGEgbmV3IGFycmF5IG9mIGRhdGEuIElmIHRoZSBhcnJheSByZWZlcmVuY2VcclxuICAgKiBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgb25lLCBpdCBkb2Vzbid0IHRyaWdnZXIgYW4gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gdXBkYXRlIHRoZSB0YWJsZSBkYXRhc291cmNlLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZnkgb3B0aW9ucyB0byB1cGRhdGUgdGhlIGRhdGFzb3VyY2UuXHJcbiAgICogSWYgZW1pdEV2ZW50IGlzIHRydWUgYW5kIHRoZSBkYXRhc291cmNlIGlzIHVwZGF0ZWQsIGl0IGVtaXRzIGFuIGV2ZW50XHJcbiAgICogZnJvbSAnZGF0YXNvdXJjZVN1YmplY3QnIHdpdGggdGhlIHVwZGF0ZWQgZGF0YS4gSWYgZmFsc2UsIGl0IGRvZXNuJ3RcclxuICAgKiBlbWl0IGFuIGV2ZW50LiBUcnVlIGJ5IGRlZmF1bHQuXHJcbiAgICovXHJcbiAgdXBkYXRlRGF0YXNvdXJjZShkYXRhOiBUW10sIG9wdGlvbnMgPSB7IGVtaXRFdmVudDogdHJ1ZSB9KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YSAhPT0gZGF0YSkge1xyXG4gICAgICB0aGlzLmN1cnJlbnREYXRhID0gZGF0YTtcclxuICAgICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHRoaXMuZ2V0Um93c0Zyb21EYXRhKGRhdGEpKVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuZW1pdEV2ZW50KVxyXG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZVN1YmplY3QubmV4dChkYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgdGhlIGV4aXN0YW5jZSBvZiB0aGUgYSBuZXcgcm93IChub3QgeWV0IHNhdmVkKS5cclxuICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBleGlzdHNOZXdFbGVtZW50KHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICEoc291cmNlLmxlbmd0aCA9PSAwIHx8IHNvdXJjZVt0aGlzLmdldE5ld1Jvd0luZGV4KHNvdXJjZSldLmlkID4gLTEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBwb3NzaWJsZSBpbmRleCBvZiB0aGUgbmV3IHJvdyBkZXBlbmRpbmcgb24gdGhlIGluc2VydGlvbiB0eXBlLlxyXG4gICAqIEl0IGRvZXNuJ3QgaW1wbHkgdGhhdCB0aGUgbmV3IHJvdyBpcyBjcmVhdGVkLCB0aGF0IG11c3QgYmUgY2hlY2tlZC5cclxuICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXROZXdSb3dJbmRleChzb3VyY2UpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cylcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBzb3VyY2UubGVuZ3RoIC0gMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJvdyBpZCBmcm9tIHRoZSBpbmRleCBzcGVjaWZpZWQuIEl0IGRvZXNcclxuICAgKiBub3QgY29uc2lkZXIgaWYgdGhlIG5ldyByb3cgaXMgcHJlc2VudCBvciBub3QsIGFzc3VtZXNcclxuICAgKiB0aGF0IG5ldyByb3cgaXMgbm90IHByZXNlbnQuXHJcbiAgICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBhcnJheS5cclxuICAgKiBAcGFyYW0gY291bnQgUXVhbnRpdHkgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXg6IG51bWJlciwgY291bnQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKVxyXG4gICAgICByZXR1cm4gY291bnQgLSAxIC0gaW5kZXg7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGluZGV4IGZyb20gdGhlIHJvdyBpZCBzcGVjaWZpZWQuXHJcbiAgICogSXQgdGFrZXMgaW50byBhY2NvdW50IGlmIHRoZSBuZXcgcm93IGV4aXN0cyBvciBub3QuXHJcbiAgICogQHBhcmFtIGlkXHJcbiAgICogQHBhcmFtIHNvdXJjZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0SW5kZXhGcm9tUm93SWQoaWQ6IG51bWJlciwgc291cmNlOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IG51bWJlciB7XHJcbiAgICBpZihpZCA9PSAtMSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5leGlzdHNOZXdFbGVtZW50KHNvdXJjZSkgPyB0aGlzLmdldE5ld1Jvd0luZGV4KHNvdXJjZSkgOiAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXHJcbiAgICAgICAgICByZXR1cm4gc291cmNlLmxlbmd0aCAtIDEgLSBpZDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSByb3dzIGlkcyBpbiB0aGUgYXJyYXkgc3BlY2lmaWVkLCBzdGFydGluZyBpbiB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICogdW50aWwgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgYXJyYXksIGRlcGVuZGluZyBvbiBjb25maWcucHJlcGVuZE5ld0VsZW1lbnRzXHJcbiAgICogY29uZmlndXJhdGlvbi5cclxuICAgKiBAcGFyYW0gaW5pdGlhbEluZGV4IEluaXRpYWwgaW5kZXggb2Ygc291cmNlIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHBhcmFtIHNvdXJjZSBBcnJheSB0aGF0IGNvbnRhaW5zIHRoZSByb3dzIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVSb3dJZHMoaW5pdGlhbEluZGV4OiBudW1iZXIsIHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cyA/IC0xIDogMTtcclxuXHJcbiAgICBmb3IgKGxldCBpbmRleCA9IGluaXRpYWxJbmRleDsgaW5kZXggPCBzb3VyY2UubGVuZ3RoICYmIGluZGV4ID49IDA7IGluZGV4ICs9IGRlbHRhKSB7XHJcbiAgICAgIGlmIChzb3VyY2VbaW5kZXhdLmlkICE9IC0xKVxyXG4gICAgICAgIHNvdXJjZVtpbmRleF0uaWQgPSB0aGlzLmdldFJvd0lkRnJvbUluZGV4KGluZGV4LCBzb3VyY2UubGVuZ3RoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSByb3dzLlxyXG4gICAqIEBwYXJhbSByb3dzIFJvd3MgdG8gZXh0cmFjdCB0aGUgZGF0YS5cclxuICAgKi9cclxuICBwcml2YXRlIGdldERhdGFGcm9tUm93cyhyb3dzOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IFRbXSB7XHJcbiAgICByZXR1cm4gcm93c1xyXG4gICAgICAuZmlsdGVyKHJvdyA9PiByb3cuaWQgIT0gLTEpXHJcbiAgICAgIC5tYXA8VD4oKHJvdykgPT4ge1xyXG4gICAgICByZXR1cm4gcm93Lm9yaWdpbmFsRGF0YSA/IHJvdy5vcmlnaW5hbERhdGEgOiByb3cuY3VycmVudERhdGE7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZGF0YXNvdXJjZSB3aXRoIHRoZSBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgc3BlY2lmaWVkIHJvd3MuXHJcbiAgICogQHBhcmFtIHJvd3MgUm93cyB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhc291cmNlJ3MgbmV3IGRhdGEuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVEYXRhc291cmNlRnJvbVJvd3Mocm93czogVGFibGVFbGVtZW50PFQ+W10pOiB2b2lkIHtcclxuICAgIHRoaXMuY3VycmVudERhdGEgPSB0aGlzLmdldERhdGFGcm9tUm93cyhyb3dzKTtcclxuICAgIHRoaXMuZGF0YXNvdXJjZVN1YmplY3QubmV4dCh0aGlzLmN1cnJlbnREYXRhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyb20gYW4gYXJyYXkgb2YgZGF0YSwgaXQgcmV0dXJucyByb3dzIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGRhdGEuXHJcbiAgICogQHBhcmFtIGFycmF5RGF0YSBEYXRhIGZyb20gd2hpY2ggY3JlYXRlIHRoZSByb3dzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Um93c0Zyb21EYXRhKGFycmF5RGF0YTogVFtdKTogVGFibGVFbGVtZW50PFQ+W10ge1xyXG4gICAgcmV0dXJuIGFycmF5RGF0YS5tYXA8VGFibGVFbGVtZW50PFQ+PigoZGF0YSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBUYWJsZUVsZW1lbnQoe1xyXG4gICAgICAgIGlkOiB0aGlzLmdldFJvd0lkRnJvbUluZGV4KGluZGV4LCBhcnJheURhdGEubGVuZ3RoKSxcclxuICAgICAgICBlZGl0aW5nOiBmYWxzZSxcclxuICAgICAgICBjdXJyZW50RGF0YTogZGF0YSxcclxuICAgICAgICBzb3VyY2U6IHRoaXMsXHJcbiAgICAgICAgdmFsaWRhdG9yOiB0aGlzLnZhbGlkYXRvclNlcnZpY2UuZ2V0Um93VmFsaWRhdG9yKCksXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBpZGVudGljYWwgc3RydWN0dXJlIHRoYW4gdGhlIHRhYmxlIHNvdXJjZSBkYXRhLlxyXG4gICAqIEl0IHVzZXMgdGhlIG9iamVjdCdzIHR5cGUgY29udHJ1Y3RvciBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCBjcmVhdGVzXHJcbiAgICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluZWQgaW4gdGhlIG9yaWdpbmFsXHJcbiAgICogZGF0YXNvdXJjZSAodXNlZCBpbiB0aGUgY29uc3RydWN0b3IpLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgY3JlYXRlTmV3T2JqZWN0KCk6IFQge1xyXG4gICAgaWYgKHRoaXMuZGF0YUNvbnN0cnVjdG9yKVxyXG4gICAgICByZXR1cm4gbmV3IHRoaXMuZGF0YUNvbnN0cnVjdG9yKCk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YUtleXMucmVkdWNlKChvYmosIGtleSkgPT4ge1xyXG4gICAgICAgIG9ialtrZXldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKiogQ29ubmVjdCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRhYmxlIHRvIHJldHJpZXZlIG9uZSBzdHJlYW0gY29udGFpbmluZ1xyXG4gICAqICB0aGUgZGF0YSB0byByZW5kZXIuICovXHJcbiAgY29ubmVjdCgpOiBPYnNlcnZhYmxlPFRhYmxlRWxlbWVudDxUPltdPiB7XHJcbiAgICByZXR1cm4gdGhpcy5yb3dzU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKSB7IH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZhbGlkYXRvclNlcnZpY2Uge1xyXG4gIGFic3RyYWN0IGdldFJvd1ZhbGlkYXRvcigpOiBGb3JtR3JvdXA7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFJQTs7O0FBRUE7Ozs7SUFxQkUsWUFBWSxJQUE4QjtRQUN4QyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUM3QixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNoQixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO2FBQ3pCO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDMUI7U0FDRjtLQUNGOzs7O0lBeEJELElBQUksV0FBVzs7UUFFYixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZFO2FBQU07WUFDTCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7U0FDMUI7S0FDRjs7Ozs7SUFFRCxJQUFJLFdBQVcsQ0FBQyxLQUFLO1FBQ25CLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFD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