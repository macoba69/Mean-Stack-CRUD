import cloneDeep from 'lodash.clonedeep';
import { Injectable } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { __extends } from 'tslib';
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, Subject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
TableElement = /** @class */ (function () {
    function TableElement(init) {
        Object.assign(this, init);
        this.fillValidatorFromData();
        if (this.validator) {
            if (this.editing) {
                this.validator.enable();
            }
            else {
                this.validator.disable();
            }
        }
    }
    Object.defineProperty(TableElement.prototype, "currentData", {
        get: /**
         * @return {?}
         */
        function () {
            //express hack
            if (this.validator) {
                return Object.assign(this._currentData, this.validator.getRawValue());
            }
            else {
                return this._currentData;
            }
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._currentData = value;
            this.fillValidatorFromData();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TableElement.prototype.fillValidatorFromData = /**
     * @return {?}
     */
    function () {
        if (this.validator) {
            var /** @type {?} */ formData = {};
            for (var /** @type {?} */ key in this.validator.controls) {
                formData[key] = this._currentData[key];
            }
            this.validator.setValue(formData);
        }
    };
    /**
     * @return {?}
     */
    TableElement.prototype.delete = /**
     * @return {?}
     */
    function () {
        this.source.delete(this.id);
    };
    /**
     * @return {?}
     */
    TableElement.prototype.confirmEditCreate = /**
     * @return {?}
     */
    function () {
        this.originalData = undefined;
        if (this.id == -1)
            return this.source.confirmCreate(this);
        else
            return this.source.confirmEdit(this);
    };
    /**
     * @return {?}
     */
    TableElement.prototype.startEdit = /**
     * @return {?}
     */
    function () {
        this.originalData = cloneDeep(this.currentData);
        this.editing = true;
        this.validator.enable();
    };
    /**
     * @return {?}
     */
    TableElement.prototype.cancelOrDelete = /**
     * @return {?}
     */
    function () {
        if (this.id == -1 || !this.editing)
            this.delete();
        else {
            this.currentData = this.originalData;
            this.editing = false;
            this.validator.disable();
        }
    };
    return TableElement;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DefaultValidatorService = /** @class */ (function () {
    function DefaultValidatorService() {
    }
    /**
     * @return {?}
     */
    DefaultValidatorService.prototype.getRowValidator = /**
     * @return {?}
     */
    function () {
        return new FormGroup({});
    };
    DefaultValidatorService.decorators = [
        { type: Injectable },
    ];
    return DefaultValidatorService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
TableDataSource = /** @class */ (function (_super) {
    __extends(TableDataSource, _super);
    /**
     * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.
     * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
     * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
     * @param validatorService Service that create instances of the FormGroup used to validate row fields.
     * @param config Additional configuration for table.
     */
    function TableDataSource(data, dataType, validatorService, config) {
        if (config === void 0) { config = { prependNewElements: false }; }
        var _this = _super.call(this) || this;
        _this.validatorService = validatorService;
        _this.config = config;
        if (!validatorService)
            _this.validatorService = new DefaultValidatorService();
        if (dataType) {
            _this.dataConstructor = dataType;
        }
        else {
            if (data && data.length > 0)
                _this.dataKeys = Object.keys(data[0]);
            else
                throw new Error('You must define either a non empty array, or an associated class to build the table.');
        }
        _this.rowsSubject = new BehaviorSubject(_this.getRowsFromData(data));
        _this.datasourceSubject = new Subject();
        return _this;
    }
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     */
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     * @return {?}
     */
    TableDataSource.prototype.createNew = /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     * @return {?}
     */
    function () {
        var /** @type {?} */ source = this.rowsSubject.getValue();
        if (!this.existsNewElement(source)) {
            var /** @type {?} */ newElement = new TableElement({
                id: -1,
                editing: true,
                currentData: this.createNewObject(),
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
            if (this.config.prependNewElements) {
                this.rowsSubject.next([newElement].concat(source));
            }
            else {
                source.push(newElement);
                this.rowsSubject.next(source);
            }
        }
    };
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param row Row to be confirmed.
     */
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param {?} row Row to be confirmed.
     * @return {?}
     */
    TableDataSource.prototype.confirmCreate = /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param {?} row Row to be confirmed.
     * @return {?}
     */
    function (row) {
        if (!row.validator.valid) {
            return false;
        }
        var /** @type {?} */ source = this.rowsSubject.getValue();
        row.id = source.length - 1;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    };
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param row Row to be edited.
     */
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param {?} row Row to be edited.
     * @return {?}
     */
    TableDataSource.prototype.confirmEdit = /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param {?} row Row to be edited.
     * @return {?}
     */
    function (row) {
        if (!row.validator.valid) {
            return false;
        }
        var /** @type {?} */ source = this.rowsSubject.getValue();
        var /** @type {?} */ index = this.getIndexFromRowId(row.id, source);
        source[index] = row;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    };
    /**
     * Delete the row with the index specified.
     */
    /**
     * Delete the row with the index specified.
     * @param {?} id
     * @return {?}
     */
    TableDataSource.prototype.delete = /**
     * Delete the row with the index specified.
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ source = this.rowsSubject.getValue();
        var /** @type {?} */ index = this.getIndexFromRowId(id, source);
        source.splice(index, 1);
        this.updateRowIds(index, source);
        this.rowsSubject.next(source);
        if (id != -1)
            this.updateDatasourceFromRows(source);
    };
    /**
   * Get row from the table.
   * @param id Id of the row to retrieve, -1 returns the current new line.
   */
    /**
     * Get row from the table.
     * @param {?} id Id of the row to retrieve, -1 returns the current new line.
     * @return {?}
     */
    TableDataSource.prototype.getRow = /**
     * Get row from the table.
     * @param {?} id Id of the row to retrieve, -1 returns the current new line.
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ source = this.rowsSubject.getValue();
        var /** @type {?} */ index = this.getIndexFromRowId(id, source);
        return (index >= 0 && index < source.length) ? source[index] : null;
    };
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param data Data to update the table datasource.
     * @param options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     */
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param {?} data Data to update the table datasource.
     * @param {?=} options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     * @return {?}
     */
    TableDataSource.prototype.updateDatasource = /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param {?} data Data to update the table datasource.
     * @param {?=} options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     * @return {?}
     */
    function (data, options) {
        if (options === void 0) { options = { emitEvent: true }; }
        if (this.currentData !== data) {
            this.currentData = data;
            this.rowsSubject.next(this.getRowsFromData(data));
            if (options.emitEvent)
                this.datasourceSubject.next(data);
        }
    };
    /**
     * Checks the existance of the a new row (not yet saved).
     * @param {?} source
     * @return {?}
     */
    TableDataSource.prototype.existsNewElement = /**
     * Checks the existance of the a new row (not yet saved).
     * @param {?} source
     * @return {?}
     */
    function (source) {
        return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
    };
    /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param {?} source
     * @return {?}
     */
    TableDataSource.prototype.getNewRowIndex = /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param {?} source
     * @return {?}
     */
    function (source) {
        if (this.config.prependNewElements)
            return 0;
        else
            return source.length - 1;
    };
    /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param {?} index Index of the array.
     * @param {?} count Quantity of elements in the array.
     * @return {?}
     */
    TableDataSource.prototype.getRowIdFromIndex = /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param {?} index Index of the array.
     * @param {?} count Quantity of elements in the array.
     * @return {?}
     */
    function (index, count) {
        if (this.config.prependNewElements)
            return count - 1 - index;
        else
            return index;
    };
    /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param {?} id
     * @param {?} source
     * @return {?}
     */
    TableDataSource.prototype.getIndexFromRowId = /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param {?} id
     * @param {?} source
     * @return {?}
     */
    function (id, source) {
        if (id == -1) {
            return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
        }
        else {
            if (this.config.prependNewElements)
                return source.length - 1 - id;
            else
                return id;
        }
    };
    /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param {?} initialIndex Initial index of source to be updated.
     * @param {?} source Array that contains the rows to be updated.
     * @return {?}
     */
    TableDataSource.prototype.updateRowIds = /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param {?} initialIndex Initial index of source to be updated.
     * @param {?} source Array that contains the rows to be updated.
     * @return {?}
     */
    function (initialIndex, source) {
        var /** @type {?} */ delta = this.config.prependNewElements ? -1 : 1;
        for (var /** @type {?} */ index = initialIndex; index < source.length && index >= 0; index += delta) {
            if (source[index].id != -1)
                source[index].id = this.getRowIdFromIndex(index, source.length);
        }
    };
    /**
     * Get the data from the rows.
     * @param {?} rows Rows to extract the data.
     * @return {?}
     */
    TableDataSource.prototype.getDataFromRows = /**
     * Get the data from the rows.
     * @param {?} rows Rows to extract the data.
     * @return {?}
     */
    function (rows) {
        return rows
            .filter(function (row) { return row.id != -1; })
            .map(function (row) {
            return row.originalData ? row.originalData : row.currentData;
        });
    };
    /**
     * Update the datasource with the data contained in the specified rows.
     * @param {?} rows Rows that contains the datasource's new data.
     * @return {?}
     */
    TableDataSource.prototype.updateDatasourceFromRows = /**
     * Update the datasource with the data contained in the specified rows.
     * @param {?} rows Rows that contains the datasource's new data.
     * @return {?}
     */
    function (rows) {
        this.currentData = this.getDataFromRows(rows);
        this.datasourceSubject.next(this.currentData);
    };
    /**
     * From an array of data, it returns rows containing the original data.
     * @param {?} arrayData Data from which create the rows.
     * @return {?}
     */
    TableDataSource.prototype.getRowsFromData = /**
     * From an array of data, it returns rows containing the original data.
     * @param {?} arrayData Data from which create the rows.
     * @return {?}
     */
    function (arrayData) {
        var _this = this;
        return arrayData.map(function (data, index) {
            return new TableElement({
                id: _this.getRowIdFromIndex(index, arrayData.length),
                editing: false,
                currentData: data,
                source: _this,
                validator: _this.validatorService.getRowValidator(),
            });
        });
    };
    /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     * @return {?}
     */
    TableDataSource.prototype.createNewObject = /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     * @return {?}
     */
    function () {
        if (this.dataConstructor)
            return new this.dataConstructor();
        else {
            return this.dataKeys.reduce(function (obj, key) {
                obj[key] = undefined;
                return obj;
            }, {});
        }
    };
    /** Connect function called by the table to retrieve one stream containing
     *  the data to render. */
    /**
     * Connect function called by the table to retrieve one stream containing
     *  the data to render.
     * @return {?}
     */
    TableDataSource.prototype.connect = /**
     * Connect function called by the table to retrieve one stream containing
     *  the data to render.
     * @return {?}
     */
    function () {
        return this.rowsSubject.asObservable();
    };
    /**
     * @return {?}
     */
    TableDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () { };
    return TableDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
var ValidatorService = /** @class */ (function () {
    function ValidatorService() {
    }
    ValidatorService.decorators = [
        { type: Injectable },
    ];
    return ValidatorService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { TableDataSource, DefaultValidatorService, TableElement, ValidatorService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlL2xpYi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1lbGVtZW50LnRzIiwibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS9saWIvYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZGVmYXVsdC12YWxpZGF0b3Iuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUvbGliL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRhdGEtc291cmNlLnRzIiwibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS9saWIvYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtdmFsaWRhdG9yLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtGb3JtR3JvdXB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbmltcG9ydCB7VGFibGVEYXRhU291cmNlfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRhdGEtc291cmNlJztcclxuXHJcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XHJcblxyXG5leHBvcnQgY2xhc3MgVGFibGVFbGVtZW50PFQ+IHtcclxuICBpZDogbnVtYmVyO1xyXG4gIGVkaXRpbmc6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGE/OiBUO1xyXG4gIG9yaWdpbmFsRGF0YTogVDtcclxuICBzb3VyY2U6IFRhYmxlRGF0YVNvdXJjZTxUPjtcclxuICB2YWxpZGF0b3I6IEZvcm1Hcm91cDtcclxuICBnZXQgY3VycmVudERhdGEoKSB7XHJcbiAgICAvL2V4cHJlc3MgaGFja1xyXG4gICAgaWYgKHRoaXMudmFsaWRhdG9yKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMuX2N1cnJlbnREYXRhLCB0aGlzLnZhbGlkYXRvci5nZXRSYXdWYWx1ZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBjdXJyZW50RGF0YSh2YWx1ZSkge1xyXG4gICAgdGhpcy5fY3VycmVudERhdGEgPSB2YWx1ZTtcclxuICAgIHRoaXMuZmlsbFZhbGlkYXRvckZyb21EYXRhKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihpbml0OiBQYXJ0aWFsPFRhYmxlRWxlbWVudDxUPj4pIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdCk7XHJcbiAgICB0aGlzLmZpbGxWYWxpZGF0b3JGcm9tRGF0YSgpO1xyXG4gICAgaWYgKHRoaXMudmFsaWRhdG9yKSB7XHJcbiAgICAgIGlmICh0aGlzLmVkaXRpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvci5lbmFibGUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvci5kaXNhYmxlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZpbGxWYWxpZGF0b3JGcm9tRGF0YSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnZhbGlkYXRvcikge1xyXG4gICAgICBsZXQgZm9ybURhdGEgPSB7fTtcclxuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMudmFsaWRhdG9yLmNvbnRyb2xzKSB7XHJcbiAgICAgICAgZm9ybURhdGFba2V5XSA9IHRoaXMuX2N1cnJlbnREYXRhW2tleV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy52YWxpZGF0b3Iuc2V0VmFsdWUoZm9ybURhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVsZXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zb3VyY2UuZGVsZXRlKHRoaXMuaWQpO1xyXG4gIH1cclxuXHJcbiAgY29uZmlybUVkaXRDcmVhdGUoKTogYm9vbGVhbiB7XHJcbiAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHVuZGVmaW5lZDtcclxuICAgIGlmICh0aGlzLmlkID09IC0xKVxyXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY29uZmlybUNyZWF0ZSh0aGlzKTtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbmZpcm1FZGl0KHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRFZGl0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5vcmlnaW5hbERhdGEgPSBjbG9uZURlZXAodGhpcy5jdXJyZW50RGF0YSk7XHJcbiAgICB0aGlzLmVkaXRpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy52YWxpZGF0b3IuZW5hYmxlKCk7XHJcbiAgfVxyXG5cclxuICBjYW5jZWxPckRlbGV0ZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlkID09IC0xIHx8ICF0aGlzLmVkaXRpbmcpXHJcbiAgICAgIHRoaXMuZGVsZXRlKCk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IHRoaXMub3JpZ2luYWxEYXRhO1xyXG4gICAgICB0aGlzLmVkaXRpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy52YWxpZGF0b3IuZGlzYWJsZSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbmltcG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLXZhbGlkYXRvci5zZXJ2aWNlJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIERlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlIGltcGxlbWVudHMgVmFsaWRhdG9yU2VydmljZSB7XHJcblxyXG4gIGdldFJvd1ZhbGlkYXRvcigpOiBGb3JtR3JvdXAge1xyXG4gICAgcmV0dXJuIG5ldyBGb3JtR3JvdXAoe30pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge0RhdGFTb3VyY2V9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XHJcblxyXG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQge1RhYmxlRWxlbWVudH0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1lbGVtZW50JztcclxuaW1wb3J0IHtWYWxpZGF0b3JTZXJ2aWNlfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLXZhbGlkYXRvci5zZXJ2aWNlJztcclxuaW1wb3J0IHtEZWZhdWx0VmFsaWRhdG9yU2VydmljZX0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1kZWZhdWx0LXZhbGlkYXRvci5zZXJ2aWNlJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVGFibGVEYXRhU291cmNlPFQ+IGV4dGVuZHMgRGF0YVNvdXJjZTxUYWJsZUVsZW1lbnQ8VD4+IHtcclxuXHJcbiAgcHJpdmF0ZSByb3dzU3ViamVjdDogQmVoYXZpb3JTdWJqZWN0PFRhYmxlRWxlbWVudDxUPltdPjtcclxuICBkYXRhc291cmNlU3ViamVjdDogU3ViamVjdDxUW10+O1xyXG5cclxuICBwcml2YXRlIGRhdGFDb25zdHJ1Y3RvcjogbmV3ICgpID0+IFQ7XHJcbiAgcHJpdmF0ZSBkYXRhS2V5czogYW55W107XHJcblxyXG4gIHByaXZhdGUgY3VycmVudERhdGE6IGFueTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBUYWJsZURhdGFTb3VyY2UgaW5zdGFuY2UsIHRoYXQgY2FuIGJlIHVzZWQgYXMgZGF0YXNvdXJjZSBvZiBgQGFuZ3VsYXIvY2RrYCBkYXRhLXRhYmxlLlxyXG4gICAqIEBwYXJhbSBkYXRhIEFycmF5IGNvbnRhaW5pbmcgdGhlIGluaXRpYWwgdmFsdWVzIGZvciB0aGUgVGFibGVEYXRhU291cmNlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGBkYXRhVHlwZWAgbXVzdCBiZSBzcGVjaWZpZWQuXHJcbiAgICogQHBhcmFtIGRhdGFUeXBlIFR5cGUgb2YgZGF0YSBjb250YWluZWQgYnkgdGhlIFRhYmxlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGBkYXRhYCB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50IG11c3QgYmUgc3BlY2lmaWVkLlxyXG4gICAqIEBwYXJhbSB2YWxpZGF0b3JTZXJ2aWNlIFNlcnZpY2UgdGhhdCBjcmVhdGUgaW5zdGFuY2VzIG9mIHRoZSBGb3JtR3JvdXAgdXNlZCB0byB2YWxpZGF0ZSByb3cgZmllbGRzLlxyXG4gICAqIEBwYXJhbSBjb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0YWJsZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGRhdGE6IFRbXSxcclxuICAgIGRhdGFUeXBlPzogbmV3ICgpID0+IFQsXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvclNlcnZpY2U/OiBWYWxpZGF0b3JTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBjb25maWcgPSB7IHByZXBlbmROZXdFbGVtZW50czogZmFsc2UgfSlcclxuICB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGlmICghdmFsaWRhdG9yU2VydmljZSlcclxuICAgICAgdGhpcy52YWxpZGF0b3JTZXJ2aWNlID0gbmV3IERlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlKCk7XHJcblxyXG4gICAgaWYgKGRhdGFUeXBlKSB7XHJcbiAgICAgIHRoaXMuZGF0YUNvbnN0cnVjdG9yID0gZGF0YVR5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApXHJcbiAgICAgICAgdGhpcy5kYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgZWl0aGVyIGEgbm9uIGVtcHR5IGFycmF5LCBvciBhbiBhc3NvY2lhdGVkIGNsYXNzIHRvIGJ1aWxkIHRoZSB0YWJsZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLmdldFJvd3NGcm9tRGF0YShkYXRhKSk7XHJcbiAgICB0aGlzLmRhdGFzb3VyY2VTdWJqZWN0ID0gbmV3IFN1YmplY3Q8VFtdPigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGNyZWF0aW9uIG9mIGEgbmV3IGVsZW1lbnQsIHB1c2hpbmcgYW4gZW1wdHktZGF0YSByb3cgaW4gdGhlIHRhYmxlLlxyXG4gICAqL1xyXG4gIGNyZWF0ZU5ldygpOiB2b2lkIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZXhpc3RzTmV3RWxlbWVudChzb3VyY2UpKSB7XHJcblxyXG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IFRhYmxlRWxlbWVudCh7XHJcbiAgICAgICAgaWQ6IC0xLFxyXG4gICAgICAgIGVkaXRpbmc6IHRydWUsXHJcbiAgICAgICAgY3VycmVudERhdGE6IHRoaXMuY3JlYXRlTmV3T2JqZWN0KCksXHJcbiAgICAgICAgc291cmNlOiB0aGlzLFxyXG4gICAgICAgIHZhbGlkYXRvcjogdGhpcy52YWxpZGF0b3JTZXJ2aWNlLmdldFJvd1ZhbGlkYXRvcigpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpIHtcclxuICAgICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoW25ld0VsZW1lbnRdLmNvbmNhdChzb3VyY2UpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzb3VyY2UucHVzaChuZXdFbGVtZW50KTtcclxuICAgICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlybSBjcmVhdGlvbiBvZiB0aGUgcm93LiBTYXZlIGNoYW5nZXMgYW5kIGRpc2FibGUgZWRpdGluZy5cclxuICAgKiBJZiB2YWxpZGF0aW9uIGFjdGl2ZSBhbmQgcm93IGRhdGEgaXMgaW52YWxpZCwgaXQgZG9lc24ndCBjb25maXJtIGNyZWF0aW9uIG5laXRoZXIgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIEBwYXJhbSByb3cgUm93IHRvIGJlIGNvbmZpcm1lZC5cclxuICAgKi9cclxuICBjb25maXJtQ3JlYXRlKHJvdzogVGFibGVFbGVtZW50PFQ+KTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXJvdy52YWxpZGF0b3IudmFsaWQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgcm93LmlkID0gc291cmNlLmxlbmd0aCAtIDE7XHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuXHJcbiAgICByb3cuZWRpdGluZyA9IGZhbHNlO1xyXG4gICAgcm93LnZhbGlkYXRvci5kaXNhYmxlKCk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVEYXRhc291cmNlRnJvbVJvd3Moc291cmNlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlybSBlZGl0aW9uIG9mIHRoZSByb3cuIFNhdmUgY2hhbmdlcyBhbmQgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIElmIHZhbGlkYXRpb24gYWN0aXZlIGFuZCByb3cgZGF0YSBpcyBpbnZhbGlkLCBpdCBkb2Vzbid0IGNvbmZpcm0gZWRpdGluZyBuZWl0aGVyIGRpc2FibGUgZWRpdGluZy5cclxuICAgKiBAcGFyYW0gcm93IFJvdyB0byBiZSBlZGl0ZWQuXHJcbiAgICovXHJcbiAgY29uZmlybUVkaXQocm93OiBUYWJsZUVsZW1lbnQ8VD4pOiBib29sZWFuIHtcclxuICAgIGlmICghcm93LnZhbGlkYXRvci52YWxpZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4RnJvbVJvd0lkKHJvdy5pZCwgc291cmNlKTtcclxuXHJcbiAgICBzb3VyY2VbaW5kZXhdID0gcm93O1xyXG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XHJcblxyXG4gICAgcm93LmVkaXRpbmcgPSBmYWxzZTtcclxuICAgIHJvdy52YWxpZGF0b3IuZGlzYWJsZSgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRGF0YXNvdXJjZUZyb21Sb3dzKHNvdXJjZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSB0aGUgcm93IHdpdGggdGhlIGluZGV4IHNwZWNpZmllZC5cclxuICAgKi9cclxuICBkZWxldGUoaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4RnJvbVJvd0lkKGlkLCBzb3VyY2UpO1xyXG5cclxuICAgIHNvdXJjZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgdGhpcy51cGRhdGVSb3dJZHMoaW5kZXgsIHNvdXJjZSk7XHJcblxyXG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XHJcblxyXG4gICAgaWYgKGlkICE9IC0xKVxyXG4gICAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAqIEdldCByb3cgZnJvbSB0aGUgdGFibGUuXHJcbiAqIEBwYXJhbSBpZCBJZCBvZiB0aGUgcm93IHRvIHJldHJpZXZlLCAtMSByZXR1cm5zIHRoZSBjdXJyZW50IG5ldyBsaW5lLlxyXG4gKi9cclxuICBnZXRSb3coaWQ6IG51bWJlcik6IFRhYmxlRWxlbWVudDxUPiB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQoaWQsIHNvdXJjZSk7XHJcblxyXG4gICAgcmV0dXJuIChpbmRleCA+PSAwICYmIGluZGV4IDwgc291cmNlLmxlbmd0aCkgPyBzb3VyY2VbaW5kZXhdIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZGF0YXNvdXJjZSB3aXRoIGEgbmV3IGFycmF5IG9mIGRhdGEuIElmIHRoZSBhcnJheSByZWZlcmVuY2VcclxuICAgKiBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgb25lLCBpdCBkb2Vzbid0IHRyaWdnZXIgYW4gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gdXBkYXRlIHRoZSB0YWJsZSBkYXRhc291cmNlLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZnkgb3B0aW9ucyB0byB1cGRhdGUgdGhlIGRhdGFzb3VyY2UuXHJcbiAgICogSWYgZW1pdEV2ZW50IGlzIHRydWUgYW5kIHRoZSBkYXRhc291cmNlIGlzIHVwZGF0ZWQsIGl0IGVtaXRzIGFuIGV2ZW50XHJcbiAgICogZnJvbSAnZGF0YXNvdXJjZVN1YmplY3QnIHdpdGggdGhlIHVwZGF0ZWQgZGF0YS4gSWYgZmFsc2UsIGl0IGRvZXNuJ3RcclxuICAgKiBlbWl0IGFuIGV2ZW50LiBUcnVlIGJ5IGRlZmF1bHQuXHJcbiAgICovXHJcbiAgdXBkYXRlRGF0YXNvdXJjZShkYXRhOiBUW10sIG9wdGlvbnMgPSB7IGVtaXRFdmVudDogdHJ1ZSB9KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YSAhPT0gZGF0YSkge1xyXG4gICAgICB0aGlzLmN1cnJlbnREYXRhID0gZGF0YTtcclxuICAgICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHRoaXMuZ2V0Um93c0Zyb21EYXRhKGRhdGEpKVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuZW1pdEV2ZW50KVxyXG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZVN1YmplY3QubmV4dChkYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgdGhlIGV4aXN0YW5jZSBvZiB0aGUgYSBuZXcgcm93IChub3QgeWV0IHNhdmVkKS5cclxuICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBleGlzdHNOZXdFbGVtZW50KHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICEoc291cmNlLmxlbmd0aCA9PSAwIHx8IHNvdXJjZVt0aGlzLmdldE5ld1Jvd0luZGV4KHNvdXJjZSldLmlkID4gLTEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBwb3NzaWJsZSBpbmRleCBvZiB0aGUgbmV3IHJvdyBkZXBlbmRpbmcgb24gdGhlIGluc2VydGlvbiB0eXBlLlxyXG4gICAqIEl0IGRvZXNuJ3QgaW1wbHkgdGhhdCB0aGUgbmV3IHJvdyBpcyBjcmVhdGVkLCB0aGF0IG11c3QgYmUgY2hlY2tlZC5cclxuICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXROZXdSb3dJbmRleChzb3VyY2UpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cylcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBzb3VyY2UubGVuZ3RoIC0gMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJvdyBpZCBmcm9tIHRoZSBpbmRleCBzcGVjaWZpZWQuIEl0IGRvZXNcclxuICAgKiBub3QgY29uc2lkZXIgaWYgdGhlIG5ldyByb3cgaXMgcHJlc2VudCBvciBub3QsIGFzc3VtZXNcclxuICAgKiB0aGF0IG5ldyByb3cgaXMgbm90IHByZXNlbnQuXHJcbiAgICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBhcnJheS5cclxuICAgKiBAcGFyYW0gY291bnQgUXVhbnRpdHkgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXg6IG51bWJlciwgY291bnQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKVxyXG4gICAgICByZXR1cm4gY291bnQgLSAxIC0gaW5kZXg7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGluZGV4IGZyb20gdGhlIHJvdyBpZCBzcGVjaWZpZWQuXHJcbiAgICogSXQgdGFrZXMgaW50byBhY2NvdW50IGlmIHRoZSBuZXcgcm93IGV4aXN0cyBvciBub3QuXHJcbiAgICogQHBhcmFtIGlkXHJcbiAgICogQHBhcmFtIHNvdXJjZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0SW5kZXhGcm9tUm93SWQoaWQ6IG51bWJlciwgc291cmNlOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IG51bWJlciB7XHJcbiAgICBpZihpZCA9PSAtMSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5leGlzdHNOZXdFbGVtZW50KHNvdXJjZSkgPyB0aGlzLmdldE5ld1Jvd0luZGV4KHNvdXJjZSkgOiAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXHJcbiAgICAgICAgICByZXR1cm4gc291cmNlLmxlbmd0aCAtIDEgLSBpZDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSByb3dzIGlkcyBpbiB0aGUgYXJyYXkgc3BlY2lmaWVkLCBzdGFydGluZyBpbiB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICogdW50aWwgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgYXJyYXksIGRlcGVuZGluZyBvbiBjb25maWcucHJlcGVuZE5ld0VsZW1lbnRzXHJcbiAgICogY29uZmlndXJhdGlvbi5cclxuICAgKiBAcGFyYW0gaW5pdGlhbEluZGV4IEluaXRpYWwgaW5kZXggb2Ygc291cmNlIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHBhcmFtIHNvdXJjZSBBcnJheSB0aGF0IGNvbnRhaW5zIHRoZSByb3dzIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVSb3dJZHMoaW5pdGlhbEluZGV4OiBudW1iZXIsIHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cyA/IC0xIDogMTtcclxuXHJcbiAgICBmb3IgKGxldCBpbmRleCA9IGluaXRpYWxJbmRleDsgaW5kZXggPCBzb3VyY2UubGVuZ3RoICYmIGluZGV4ID49IDA7IGluZGV4ICs9IGRlbHRhKSB7XHJcbiAgICAgIGlmIChzb3VyY2VbaW5kZXhdLmlkICE9IC0xKVxyXG4gICAgICAgIHNvdXJjZVtpbmRleF0uaWQgPSB0aGlzLmdldFJvd0lkRnJvbUluZGV4KGluZGV4LCBzb3VyY2UubGVuZ3RoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSByb3dzLlxyXG4gICAqIEBwYXJhbSByb3dzIFJvd3MgdG8gZXh0cmFjdCB0aGUgZGF0YS5cclxuICAgKi9cclxuICBwcml2YXRlIGdldERhdGFGcm9tUm93cyhyb3dzOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IFRbXSB7XHJcbiAgICByZXR1cm4gcm93c1xyXG4gICAgICAuZmlsdGVyKHJvdyA9PiByb3cuaWQgIT0gLTEpXHJcbiAgICAgIC5tYXA8VD4oKHJvdykgPT4ge1xyXG4gICAgICByZXR1cm4gcm93Lm9yaWdpbmFsRGF0YSA/IHJvdy5vcmlnaW5hbERhdGEgOiByb3cuY3VycmVudERhdGE7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZGF0YXNvdXJjZSB3aXRoIHRoZSBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgc3BlY2lmaWVkIHJvd3MuXHJcbiAgICogQHBhcmFtIHJvd3MgUm93cyB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhc291cmNlJ3MgbmV3IGRhdGEuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVEYXRhc291cmNlRnJvbVJvd3Mocm93czogVGFibGVFbGVtZW50PFQ+W10pOiB2b2lkIHtcclxuICAgIHRoaXMuY3VycmVudERhdGEgPSB0aGlzLmdldERhdGFGcm9tUm93cyhyb3dzKTtcclxuICAgIHRoaXMuZGF0YXNvdXJjZVN1YmplY3QubmV4dCh0aGlzLmN1cnJlbnREYXRhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyb20gYW4gYXJyYXkgb2YgZGF0YSwgaXQgcmV0dXJucyByb3dzIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGRhdGEuXHJcbiAgICogQHBhcmFtIGFycmF5RGF0YSBEYXRhIGZyb20gd2hpY2ggY3JlYXRlIHRoZSByb3dzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Um93c0Zyb21EYXRhKGFycmF5RGF0YTogVFtdKTogVGFibGVFbGVtZW50PFQ+W10ge1xyXG4gICAgcmV0dXJuIGFycmF5RGF0YS5tYXA8VGFibGVFbGVtZW50PFQ+PigoZGF0YSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBUYWJsZUVsZW1lbnQoe1xyXG4gICAgICAgIGlkOiB0aGlzLmdldFJvd0lkRnJvbUluZGV4KGluZGV4LCBhcnJheURhdGEubGVuZ3RoKSxcclxuICAgICAgICBlZGl0aW5nOiBmYWxzZSxcclxuICAgICAgICBjdXJyZW50RGF0YTogZGF0YSxcclxuICAgICAgICBzb3VyY2U6IHRoaXMsXHJcbiAgICAgICAgdmFsaWRhdG9yOiB0aGlzLnZhbGlkYXRvclNlcnZpY2UuZ2V0Um93VmFsaWRhdG9yKCksXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBpZGVudGljYWwgc3RydWN0dXJlIHRoYW4gdGhlIHRhYmxlIHNvdXJjZSBkYXRhLlxyXG4gICAqIEl0IHVzZXMgdGhlIG9iamVjdCdzIHR5cGUgY29udHJ1Y3RvciBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCBjcmVhdGVzXHJcbiAgICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluZWQgaW4gdGhlIG9yaWdpbmFsXHJcbiAgICogZGF0YXNvdXJjZSAodXNlZCBpbiB0aGUgY29uc3RydWN0b3IpLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgY3JlYXRlTmV3T2JqZWN0KCk6IFQge1xyXG4gICAgaWYgKHRoaXMuZGF0YUNvbnN0cnVjdG9yKVxyXG4gICAgICByZXR1cm4gbmV3IHRoaXMuZGF0YUNvbnN0cnVjdG9yKCk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YUtleXMucmVkdWNlKChvYmosIGtleSkgPT4ge1xyXG4gICAgICAgIG9ialtrZXldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKiogQ29ubmVjdCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRhYmxlIHRvIHJldHJpZXZlIG9uZSBzdHJlYW0gY29udGFpbmluZ1xyXG4gICAqICB0aGUgZGF0YSB0byByZW5kZXIuICovXHJcbiAgY29ubmVjdCgpOiBPYnNlcnZhYmxlPFRhYmxlRWxlbWVudDxUPltdPiB7XHJcbiAgICByZXR1cm4gdGhpcy5yb3dzU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKSB7IH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZhbGlkYXRvclNlcnZpY2Uge1xyXG4gIGFic3RyYWN0IGdldFJvd1ZhbGlkYXRvcigpOiBGb3JtR3JvdXA7XHJcbn1cclxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUlBOzs7QUFFQTs7O0FBQUE7SUFxQkUsc0JBQVksSUFBOEI7UUFDeEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDN0IsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDaEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQzthQUN6QjtpQkFBTTtnQkFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzFCO1NBQ0Y7S0FDRjtJQXhCRCxzQkFBSSxxQ0FBVzs7OztRQUFmOztZQUVFLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDbEIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZFO2lCQUFNO2dCQUNMLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQzthQUMxQjtTQUNGOzs7OztRQUVELFVBQWdCLEtBQUs7WUFDbkIsSUFB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