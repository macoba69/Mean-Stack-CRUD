/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, Subject } from 'rxjs';
import { TableElement } from './angular6-material-table-element';
import { DefaultValidatorService } from './angular6-material-table-default-validator.service';
/**
 * @template T
 */
export class TableDataSource extends DataSource {
    /**
     * Creates a new TableDataSource instance, that can be used as datasource of `\@angular/cdk` data-table.
     * @param {?} data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
     * @param {?=} dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
     * @param {?=} validatorService Service that create instances of the FormGroup used to validate row fields.
     * @param {?=} config Additional configuration for table.
     */
    constructor(data, dataType, validatorService, config = { prependNewElements: false }) {
        super();
        this.validatorService = validatorService;
        this.config = config;
        if (!validatorService)
            this.validatorService = new DefaultValidatorService();
        if (dataType) {
            this.dataConstructor = dataType;
        }
        else {
            if (data && data.length > 0)
                this.dataKeys = Object.keys(data[0]);
            else
                throw new Error('You must define either a non empty array, or an associated class to build the table.');
        }
        this.rowsSubject = new BehaviorSubject(this.getRowsFromData(data));
        this.datasourceSubject = new Subject();
    }
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     * @return {?}
     */
    createNew() {
        const /** @type {?} */ source = this.rowsSubject.getValue();
        if (!this.existsNewElement(source)) {
            const /** @type {?} */ newElement = new TableElement({
                id: -1,
                editing: true,
                currentData: this.createNewObject(),
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
            if (this.config.prependNewElements) {
                this.rowsSubject.next([newElement].concat(source));
            }
            else {
                source.push(newElement);
                this.rowsSubject.next(source);
            }
        }
    }
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param {?} row Row to be confirmed.
     * @return {?}
     */
    confirmCreate(row) {
        if (!row.validator.valid) {
            return false;
        }
        const /** @type {?} */ source = this.rowsSubject.getValue();
        row.id = source.length - 1;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    }
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param {?} row Row to be edited.
     * @return {?}
     */
    confirmEdit(row) {
        if (!row.validator.valid) {
            return false;
        }
        const /** @type {?} */ source = this.rowsSubject.getValue();
        const /** @type {?} */ index = this.getIndexFromRowId(row.id, source);
        source[index] = row;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    }
    /**
     * Delete the row with the index specified.
     * @param {?} id
     * @return {?}
     */
    delete(id) {
        const /** @type {?} */ source = this.rowsSubject.getValue();
        const /** @type {?} */ index = this.getIndexFromRowId(id, source);
        source.splice(index, 1);
        this.updateRowIds(index, source);
        this.rowsSubject.next(source);
        if (id != -1)
            this.updateDatasourceFromRows(source);
    }
    /**
     * Get row from the table.
     * @param {?} id Id of the row to retrieve, -1 returns the current new line.
     * @return {?}
     */
    getRow(id) {
        const /** @type {?} */ source = this.rowsSubject.getValue();
        const /** @type {?} */ index = this.getIndexFromRowId(id, source);
        return (index >= 0 && index < source.length) ? source[index] : null;
    }
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param {?} data Data to update the table datasource.
     * @param {?=} options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     * @return {?}
     */
    updateDatasource(data, options = { emitEvent: true }) {
        if (this.currentData !== data) {
            this.currentData = data;
            this.rowsSubject.next(this.getRowsFromData(data));
            if (options.emitEvent)
                this.datasourceSubject.next(data);
        }
    }
    /**
     * Checks the existance of the a new row (not yet saved).
     * @param {?} source
     * @return {?}
     */
    existsNewElement(source) {
        return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
    }
    /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param {?} source
     * @return {?}
     */
    getNewRowIndex(source) {
        if (this.config.prependNewElements)
            return 0;
        else
            return source.length - 1;
    }
    /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param {?} index Index of the array.
     * @param {?} count Quantity of elements in the array.
     * @return {?}
     */
    getRowIdFromIndex(index, count) {
        if (this.config.prependNewElements)
            return count - 1 - index;
        else
            return index;
    }
    /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param {?} id
     * @param {?} source
     * @return {?}
     */
    getIndexFromRowId(id, source) {
        if (id == -1) {
            return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
        }
        else {
            if (this.config.prependNewElements)
                return source.length - 1 - id;
            else
                return id;
        }
    }
    /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param {?} initialIndex Initial index of source to be updated.
     * @param {?} source Array that contains the rows to be updated.
     * @return {?}
     */
    updateRowIds(initialIndex, source) {
        const /** @type {?} */ delta = this.config.prependNewElements ? -1 : 1;
        for (let /** @type {?} */ index = initialIndex; index < source.length && index >= 0; index += delta) {
            if (source[index].id != -1)
                source[index].id = this.getRowIdFromIndex(index, source.length);
        }
    }
    /**
     * Get the data from the rows.
     * @param {?} rows Rows to extract the data.
     * @return {?}
     */
    getDataFromRows(rows) {
        return rows
            .filter(row => row.id != -1)
            .map((row) => {
            return row.originalData ? row.originalData : row.currentData;
        });
    }
    /**
     * Update the datasource with the data contained in the specified rows.
     * @param {?} rows Rows that contains the datasource's new data.
     * @return {?}
     */
    updateDatasourceFromRows(rows) {
        this.currentData = this.getDataFromRows(rows);
        this.datasourceSubject.next(this.currentData);
    }
    /**
     * From an array of data, it returns rows containing the original data.
     * @param {?} arrayData Data from which create the rows.
     * @return {?}
     */
    getRowsFromData(arrayData) {
        return arrayData.map((data, index) => {
            return new TableElement({
                id: this.getRowIdFromIndex(index, arrayData.length),
                editing: false,
                currentData: data,
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
        });
    }
    /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     * @return {?}
     */
    createNewObject() {
        if (this.dataConstructor)
            return new this.dataConstructor();
        else {
            return this.dataKeys.reduce((obj, key) => {
                obj[key] = undefined;
                return obj;
            }, {});
        }
    }
    /**
     * Connect function called by the table to retrieve one stream containing
     *  the data to render.
     * @return {?}
     */
    connect() {
        return this.rowsSubject.asObservable();
    }
    /**
     * @return {?}
     */
    disconnect() { }
}
function TableDataSource_tsickle_Closure_declarations() {
    /** @type {?} */
    TableDataSource.prototype.rowsSubject;
    /** @type {?} */
    TableDataSource.prototype.datasourceSubject;
    /** @type {?} */
    TableDataSource.prototype.dataConstructor;
    /** @type {?} */
    TableDataSource.prototype.dataKeys;
    /** @type {?} */
    TableDataSource.prototype.currentData;
    /** @type {?} */
    TableDataSource.prototype.validatorService;
    /** @type {?} */
    TableDataSource.prototype.config;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZGF0YS1zb3VyY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS8iLCJzb3VyY2VzIjpbImxpYi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1kYXRhLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRXBELE9BQU8sRUFBQyxlQUFlLEVBQWMsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBRTFELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxtQ0FBbUMsQ0FBQztBQUUvRCxPQUFPLEVBQUMsdUJBQXVCLEVBQUMsTUFBTSxxREFBcUQsQ0FBQzs7OztBQUc1RixNQUFNLHNCQUEwQixTQUFRLFVBQTJCOzs7Ozs7OztJQWlCakUsWUFDRSxJQUFTLEVBQ1QsUUFBc0IsRUFDZCxrQkFDQSxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFO1FBRTlDLEtBQUssRUFBRSxDQUFDO1FBSEEscUJBQWdCLEdBQWhCLGdCQUFnQjtRQUNoQixXQUFNLEdBQU4sTUFBTTtRQUlkLEVBQUUsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7WUFDcEIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksdUJBQXVCLEVBQUUsQ0FBQztRQUV4RCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUM7U0FDakM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztnQkFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUk7Z0JBQ0YsTUFBTSxJQUFJ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QUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Ozs7Ozs7SUFPeEMsZUFBZSxDQUFDLFNBQWM7UUFDcEMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQWtCLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3BELE1BQU0sQ0FBQyxJQUFJLFlBQVksQ0FBQztnQkFDdEIsRUFBRSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQztnQkFDbkQsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsV0FBVyxFQUFFLElBQUk7Z0JBQ2pCLE1BQU0sRUFBRSxJQUFJO2dCQUNaLFNBQVMsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxFQUFFO2FBQ25ELENBQUMsQ0FBQTtTQUNILENBQUMsQ0FBQzs7Ozs7Ozs7O0lBU0csZUFBZTtRQUNyQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ3ZCLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUNwQyxJQUFJLENBQUMsQ0FBQztZQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtnQkFDdkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztnQkFDckIsTUFBTSxDQUFDLEdBQUcsQ0FBQzthQUNaLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDUjs7Ozs7OztJQU1ILE9BQU87UUFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztLQUN4Qzs7OztJQUVELFVBQVUsTUFBTTtDQUNqQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGF0YVNvdXJjZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcclxuXHJcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7VGFibGVFbGVtZW50fSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWVsZW1lbnQnO1xyXG5pbXBvcnQge1ZhbGlkYXRvclNlcnZpY2V9IGZyb20gJy4vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtdmFsaWRhdG9yLnNlcnZpY2UnO1xyXG5pbXBvcnQge0RlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRlZmF1bHQtdmFsaWRhdG9yLnNlcnZpY2UnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBUYWJsZURhdGFTb3VyY2U8VD4gZXh0ZW5kcyBEYXRhU291cmNlPFRhYmxlRWxlbWVudDxUPj4ge1xyXG5cclxuICBwcml2YXRlIHJvd3NTdWJqZWN0OiBCZWhhdmlvclN1YmplY3Q8VGFibGVFbGVtZW50PFQ+W10+O1xyXG4gIGRhdGFzb3VyY2VTdWJqZWN0OiBTdWJqZWN0PFRbXT47XHJcblxyXG4gIHByaXZhdGUgZGF0YUNvbnN0cnVjdG9yOiBuZXcgKCkgPT4gVDtcclxuICBwcml2YXRlIGRhdGFLZXlzOiBhbnlbXTtcclxuXHJcbiAgcHJpdmF0ZSBjdXJyZW50RGF0YTogYW55O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFRhYmxlRGF0YVNvdXJjZSBpbnN0YW5jZSwgdGhhdCBjYW4gYmUgdXNlZCBhcyBkYXRhc291cmNlIG9mIGBAYW5ndWxhci9jZGtgIGRhdGEtdGFibGUuXHJcbiAgICogQHBhcmFtIGRhdGEgQXJyYXkgY29udGFpbmluZyB0aGUgaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBUYWJsZURhdGFTb3VyY2UuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYGRhdGFUeXBlYCBtdXN0IGJlIHNwZWNpZmllZC5cclxuICAgKiBAcGFyYW0gZGF0YVR5cGUgVHlwZSBvZiBkYXRhIGNvbnRhaW5lZCBieSB0aGUgVGFibGUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYGRhdGFgIHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQgbXVzdCBiZSBzcGVjaWZpZWQuXHJcbiAgICogQHBhcmFtIHZhbGlkYXRvclNlcnZpY2UgU2VydmljZSB0aGF0IGNyZWF0ZSBpbnN0YW5jZXMgb2YgdGhlIEZvcm1Hcm91cCB1c2VkIHRvIHZhbGlkYXRlIHJvdyBmaWVsZHMuXHJcbiAgICogQHBhcmFtIGNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRhYmxlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZGF0YTogVFtdLFxyXG4gICAgZGF0YVR5cGU/OiBuZXcgKCkgPT4gVCxcclxuICAgIHByaXZhdGUgdmFsaWRhdG9yU2VydmljZT86IFZhbGlkYXRvclNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGNvbmZpZyA9IHsgcHJlcGVuZE5ld0VsZW1lbnRzOiBmYWxzZSB9KVxyXG4gIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgaWYgKCF2YWxpZGF0b3JTZXJ2aWNlKVxyXG4gICAgICB0aGlzLnZhbGlkYXRvclNlcnZpY2UgPSBuZXcgRGVmYXVsdFZhbGlkYXRvclNlcnZpY2UoKTtcclxuXHJcbiAgICBpZiAoZGF0YVR5cGUpIHtcclxuICAgICAgdGhpcy5kYXRhQ29uc3RydWN0b3IgPSBkYXRhVHlwZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMClcclxuICAgICAgICB0aGlzLmRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGRlZmluZSBlaXRoZXIgYSBub24gZW1wdHkgYXJyYXksIG9yIGFuIGFzc29jaWF0ZWQgY2xhc3MgdG8gYnVpbGQgdGhlIHRhYmxlLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucm93c1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuZ2V0Um93c0Zyb21EYXRhKGRhdGEpKTtcclxuICAgIHRoaXMuZGF0YXNvdXJjZVN1YmplY3QgPSBuZXcgU3ViamVjdDxUW10+KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgY3JlYXRpb24gb2YgYSBuZXcgZWxlbWVudCwgcHVzaGluZyBhbiBlbXB0eS1kYXRhIHJvdyBpbiB0aGUgdGFibGUuXHJcbiAgICovXHJcbiAgY3JlYXRlTmV3KCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG5cclxuICAgIGlmICghdGhpcy5leGlzdHNOZXdFbGVtZW50KHNvdXJjZSkpIHtcclxuXHJcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBuZXcgVGFibGVFbGVtZW50KHtcclxuICAgICAgICBpZDogLTEsXHJcbiAgICAgICAgZWRpdGluZzogdHJ1ZSxcclxuICAgICAgICBjdXJyZW50RGF0YTogdGhpcy5jcmVhdGVOZXdPYmplY3QoKSxcclxuICAgICAgICBzb3VyY2U6IHRoaXMsXHJcbiAgICAgICAgdmFsaWRhdG9yOiB0aGlzLnZhbGlkYXRvclNlcnZpY2UuZ2V0Um93VmFsaWRhdG9yKCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cykge1xyXG4gICAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dChbbmV3RWxlbWVudF0uY29uY2F0KHNvdXJjZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNvdXJjZS5wdXNoKG5ld0VsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maXJtIGNyZWF0aW9uIG9mIHRoZSByb3cuIFNhdmUgY2hhbmdlcyBhbmQgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIElmIHZhbGlkYXRpb24gYWN0aXZlIGFuZCByb3cgZGF0YSBpcyBpbnZhbGlkLCBpdCBkb2Vzbid0IGNvbmZpcm0gY3JlYXRpb24gbmVpdGhlciBkaXNhYmxlIGVkaXRpbmcuXHJcbiAgICogQHBhcmFtIHJvdyBSb3cgdG8gYmUgY29uZmlybWVkLlxyXG4gICAqL1xyXG4gIGNvbmZpcm1DcmVhdGUocm93OiBUYWJsZUVsZW1lbnQ8VD4pOiBib29sZWFuIHtcclxuICAgIGlmICghcm93LnZhbGlkYXRvci52YWxpZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICByb3cuaWQgPSBzb3VyY2UubGVuZ3RoIC0gMTtcclxuICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xyXG5cclxuICAgIHJvdy5lZGl0aW5nID0gZmFsc2U7XHJcbiAgICByb3cudmFsaWRhdG9yLmRpc2FibGUoKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maXJtIGVkaXRpb24gb2YgdGhlIHJvdy4gU2F2ZSBjaGFuZ2VzIGFuZCBkaXNhYmxlIGVkaXRpbmcuXHJcbiAgICogSWYgdmFsaWRhdGlvbiBhY3RpdmUgYW5kIHJvdyBkYXRhIGlzIGludmFsaWQsIGl0IGRvZXNuJ3QgY29uZmlybSBlZGl0aW5nIG5laXRoZXIgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIEBwYXJhbSByb3cgUm93IHRvIGJlIGVkaXRlZC5cclxuICAgKi9cclxuICBjb25maXJtRWRpdChyb3c6IFRhYmxlRWxlbWVudDxUPik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKCFyb3cudmFsaWRhdG9yLnZhbGlkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQocm93LmlkLCBzb3VyY2UpO1xyXG5cclxuICAgIHNvdXJjZVtpbmRleF0gPSByb3c7XHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuXHJcbiAgICByb3cuZWRpdGluZyA9IGZhbHNlO1xyXG4gICAgcm93LnZhbGlkYXRvci5kaXNhYmxlKCk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVEYXRhc291cmNlRnJvbVJvd3Moc291cmNlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIHRoZSByb3cgd2l0aCB0aGUgaW5kZXggc3BlY2lmaWVkLlxyXG4gICAqL1xyXG4gIGRlbGV0ZShpZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQoaWQsIHNvdXJjZSk7XHJcblxyXG4gICAgc291cmNlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB0aGlzLnVwZGF0ZVJvd0lkcyhpbmRleCwgc291cmNlKTtcclxuXHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuXHJcbiAgICBpZiAoaWQgIT0gLTEpXHJcbiAgICAgIHRoaXMudXBkYXRlRGF0YXNvdXJjZUZyb21Sb3dzKHNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICogR2V0IHJvdyBmcm9tIHRoZSB0YWJsZS5cclxuICogQHBhcmFtIGlkIElkIG9mIHRoZSByb3cgdG8gcmV0cmlldmUsIC0xIHJldHVybnMgdGhlIGN1cnJlbnQgbmV3IGxpbmUuXHJcbiAqL1xyXG4gIGdldFJvdyhpZDogbnVtYmVyKTogVGFibGVFbGVtZW50PFQ+IHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleEZyb21Sb3dJZChpZCwgc291cmNlKTtcclxuXHJcbiAgICByZXR1cm4gKGluZGV4ID49IDAgJiYgaW5kZXggPCBzb3VyY2UubGVuZ3RoKSA/IHNvdXJjZVtpbmRleF0gOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBkYXRhc291cmNlIHdpdGggYSBuZXcgYXJyYXkgb2YgZGF0YS4gSWYgdGhlIGFycmF5IHJlZmVyZW5jZVxyXG4gICAqIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBvbmUsIGl0IGRvZXNuJ3QgdHJpZ2dlciBhbiB1cGRhdGUuXHJcbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byB1cGRhdGUgdGhlIHRhYmxlIGRhdGFzb3VyY2UuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgU3BlY2lmeSBvcHRpb25zIHRvIHVwZGF0ZSB0aGUgZGF0YXNvdXJjZS5cclxuICAgKiBJZiBlbWl0RXZlbnQgaXMgdHJ1ZSBhbmQgdGhlIGRhdGFzb3VyY2UgaXMgdXBkYXRlZCwgaXQgZW1pdHMgYW4gZXZlbnRcclxuICAgKiBmcm9tICdkYXRhc291cmNlU3ViamVjdCcgd2l0aCB0aGUgdXBkYXRlZCBkYXRhLiBJZiBmYWxzZSwgaXQgZG9lc24ndFxyXG4gICAqIGVtaXQgYW4gZXZlbnQuIFRydWUgYnkgZGVmYXVsdC5cclxuICAgKi9cclxuICB1cGRhdGVEYXRhc291cmNlKGRhdGE6IFRbXSwgb3B0aW9ucyA9IHsgZW1pdEV2ZW50OiB0cnVlIH0pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmN1cnJlbnREYXRhICE9PSBkYXRhKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xyXG4gICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQodGhpcy5nZXRSb3dzRnJvbURhdGEoZGF0YSkpXHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5lbWl0RXZlbnQpXHJcbiAgICAgICAgdGhpcy5kYXRhc291cmNlU3ViamVjdC5uZXh0KGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB0aGUgZXhpc3RhbmNlIG9mIHRoZSBhIG5ldyByb3cgKG5vdCB5ZXQgc2F2ZWQpLlxyXG4gICAqIEBwYXJhbSBzb3VyY2VcclxuICAgKi9cclxuICBwcml2YXRlIGV4aXN0c05ld0VsZW1lbnQoc291cmNlOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gIShzb3VyY2UubGVuZ3RoID09IDAgfHwgc291cmNlW3RoaXMuZ2V0TmV3Um93SW5kZXgoc291cmNlKV0uaWQgPiAtMSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHBvc3NpYmxlIGluZGV4IG9mIHRoZSBuZXcgcm93IGRlcGVuZGluZyBvbiB0aGUgaW5zZXJ0aW9uIHR5cGUuXHJcbiAgICogSXQgZG9lc24ndCBpbXBseSB0aGF0IHRoZSBuZXcgcm93IGlzIGNyZWF0ZWQsIHRoYXQgbXVzdCBiZSBjaGVja2VkLlxyXG4gICAqIEBwYXJhbSBzb3VyY2VcclxuICAgKi9cclxuICBwcml2YXRlIGdldE5ld1Jvd0luZGV4KHNvdXJjZSk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIHNvdXJjZS5sZW5ndGggLSAxO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcm93IGlkIGZyb20gdGhlIGluZGV4IHNwZWNpZmllZC4gSXQgZG9lc1xyXG4gICAqIG5vdCBjb25zaWRlciBpZiB0aGUgbmV3IHJvdyBpcyBwcmVzZW50IG9yIG5vdCwgYXNzdW1lc1xyXG4gICAqIHRoYXQgbmV3IHJvdyBpcyBub3QgcHJlc2VudC5cclxuICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGFycmF5LlxyXG4gICAqIEBwYXJhbSBjb3VudCBRdWFudGl0eSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRSb3dJZEZyb21JbmRleChpbmRleDogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXHJcbiAgICAgIHJldHVybiBjb3VudCAtIDEgLSBpbmRleDtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW5kZXggZnJvbSB0aGUgcm93IGlkIHNwZWNpZmllZC5cclxuICAgKiBJdCB0YWtlcyBpbnRvIGFjY291bnQgaWYgdGhlIG5ldyByb3cgZXhpc3RzIG9yIG5vdC5cclxuICAgKiBAcGFyYW0gaWRcclxuICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRJbmRleEZyb21Sb3dJZChpZDogbnVtYmVyLCBzb3VyY2U6IFRhYmxlRWxlbWVudDxUPltdKTogbnVtYmVyIHtcclxuICAgIGlmKGlkID09IC0xKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmV4aXN0c05ld0VsZW1lbnQoc291cmNlKSA/IHRoaXMuZ2V0TmV3Um93SW5kZXgoc291cmNlKSA6IC0xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cylcclxuICAgICAgICAgIHJldHVybiBzb3VyY2UubGVuZ3RoIC0gMSAtIGlkO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHJvd3MgaWRzIGluIHRoZSBhcnJheSBzcGVjaWZpZWQsIHN0YXJ0aW5nIGluIHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgKiB1bnRpbCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBhcnJheSwgZGVwZW5kaW5nIG9uIGNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHNcclxuICAgKiBjb25maWd1cmF0aW9uLlxyXG4gICAqIEBwYXJhbSBpbml0aWFsSW5kZXggSW5pdGlhbCBpbmRleCBvZiBzb3VyY2UgdG8gYmUgdXBkYXRlZC5cclxuICAgKiBAcGFyYW0gc291cmNlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJvd3MgdG8gYmUgdXBkYXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZVJvd0lkcyhpbml0aWFsSW5kZXg6IG51bWJlciwgc291cmNlOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzID8gLTEgOiAxO1xyXG5cclxuICAgIGZvciAobGV0IGluZGV4ID0gaW5pdGlhbEluZGV4OyBpbmRleCA8IHNvdXJjZS5sZW5ndGggJiYgaW5kZXggPj0gMDsgaW5kZXggKz0gZGVsdGEpIHtcclxuICAgICAgaWYgKHNvdXJjZVtpbmRleF0uaWQgIT0gLTEpXHJcbiAgICAgICAgc291cmNlW2luZGV4XS5pZCA9IHRoaXMuZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXgsIHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIHJvd3MuXHJcbiAgICogQHBhcmFtIHJvd3MgUm93cyB0byBleHRyYWN0IHRoZSBkYXRhLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0RGF0YUZyb21Sb3dzKHJvd3M6IFRhYmxlRWxlbWVudDxUPltdKTogVFtdIHtcclxuICAgIHJldHVybiByb3dzXHJcbiAgICAgIC5maWx0ZXIocm93ID0+IHJvdy5pZCAhPSAtMSlcclxuICAgICAgLm1hcDxUPigocm93KSA9PiB7XHJcbiAgICAgIHJldHVybiByb3cub3JpZ2luYWxEYXRhID8gcm93Lm9yaWdpbmFsRGF0YSA6IHJvdy5jdXJyZW50RGF0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBkYXRhc291cmNlIHdpdGggdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBzcGVjaWZpZWQgcm93cy5cclxuICAgKiBAcGFyYW0gcm93cyBSb3dzIHRoYXQgY29udGFpbnMgdGhlIGRhdGFzb3VyY2UncyBuZXcgZGF0YS5cclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhyb3dzOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Sb3dzKHJvd3MpO1xyXG4gICAgdGhpcy5kYXRhc291cmNlU3ViamVjdC5uZXh0KHRoaXMuY3VycmVudERhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJvbSBhbiBhcnJheSBvZiBkYXRhLCBpdCByZXR1cm5zIHJvd3MgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgZGF0YS5cclxuICAgKiBAcGFyYW0gYXJyYXlEYXRhIERhdGEgZnJvbSB3aGljaCBjcmVhdGUgdGhlIHJvd3MuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRSb3dzRnJvbURhdGEoYXJyYXlEYXRhOiBUW10pOiBUYWJsZUVsZW1lbnQ8VD5bXSB7XHJcbiAgICByZXR1cm4gYXJyYXlEYXRhLm1hcDxUYWJsZUVsZW1lbnQ8VD4+KChkYXRhLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFRhYmxlRWxlbWVudCh7XHJcbiAgICAgICAgaWQ6IHRoaXMuZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXgsIGFycmF5RGF0YS5sZW5ndGgpLFxyXG4gICAgICAgIGVkaXRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGN1cnJlbnREYXRhOiBkYXRhLFxyXG4gICAgICAgIHNvdXJjZTogdGhpcyxcclxuICAgICAgICB2YWxpZGF0b3I6IHRoaXMudmFsaWRhdG9yU2VydmljZS5nZXRSb3dWYWxpZGF0b3IoKSxcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIGlkZW50aWNhbCBzdHJ1Y3R1cmUgdGhhbiB0aGUgdGFibGUgc291cmNlIGRhdGEuXHJcbiAgICogSXQgdXNlcyB0aGUgb2JqZWN0J3MgdHlwZSBjb250cnVjdG9yIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGl0IGNyZWF0ZXNcclxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5lZCBpbiB0aGUgb3JpZ2luYWxcclxuICAgKiBkYXRhc291cmNlICh1c2VkIGluIHRoZSBjb25zdHJ1Y3RvcikuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVOZXdPYmplY3QoKTogVCB7XHJcbiAgICBpZiAodGhpcy5kYXRhQ29uc3RydWN0b3IpXHJcbiAgICAgIHJldHVybiBuZXcgdGhpcy5kYXRhQ29uc3RydWN0b3IoKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhS2V5cy5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XHJcbiAgICAgICAgb2JqW2tleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSwge30pO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8qKiBDb25uZWN0IGZ1bmN0aW9uIGNhbGxlZCBieSB0aGUgdGFibGUgdG8gcmV0cmlldmUgb25lIHN0cmVhbSBjb250YWluaW5nXHJcbiAgICogIHRoZSBkYXRhIHRvIHJlbmRlci4gKi9cclxuICBjb25uZWN0KCk6IE9ic2VydmFibGU8VGFibGVFbGVtZW50PFQ+W10+IHtcclxuICAgIHJldHVybiB0aGlzLnJvd3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgZGlzY29ubmVjdCgpIHsgfVxyXG59XHJcbiJdfQ==