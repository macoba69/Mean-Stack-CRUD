/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, Subject } from 'rxjs';
import { TableElement } from './angular6-material-table-element';
import { DefaultValidatorService } from './angular6-material-table-default-validator.service';
/**
 * @template T
 */
var /**
 * @template T
 */
TableDataSource = /** @class */ (function (_super) {
    tslib_1.__extends(TableDataSource, _super);
    /**
     * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.
     * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
     * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
     * @param validatorService Service that create instances of the FormGroup used to validate row fields.
     * @param config Additional configuration for table.
     */
    function TableDataSource(data, dataType, validatorService, config) {
        if (config === void 0) { config = { prependNewElements: false }; }
        var _this = _super.call(this) || this;
        _this.validatorService = validatorService;
        _this.config = config;
        if (!validatorService)
            _this.validatorService = new DefaultValidatorService();
        if (dataType) {
            _this.dataConstructor = dataType;
        }
        else {
            if (data && data.length > 0)
                _this.dataKeys = Object.keys(data[0]);
            else
                throw new Error('You must define either a non empty array, or an associated class to build the table.');
        }
        _this.rowsSubject = new BehaviorSubject(_this.getRowsFromData(data));
        _this.datasourceSubject = new Subject();
        return _this;
    }
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     */
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     * @return {?}
     */
    TableDataSource.prototype.createNew = /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     * @return {?}
     */
    function () {
        var /** @type {?} */ source = this.rowsSubject.getValue();
        if (!this.existsNewElement(source)) {
            var /** @type {?} */ newElement = new TableElement({
                id: -1,
                editing: true,
                currentData: this.createNewObject(),
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
            if (this.config.prependNewElements) {
                this.rowsSubject.next([newElement].concat(source));
            }
            else {
                source.push(newElement);
                this.rowsSubject.next(source);
            }
        }
    };
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param row Row to be confirmed.
     */
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param {?} row Row to be confirmed.
     * @return {?}
     */
    TableDataSource.prototype.confirmCreate = /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param {?} row Row to be confirmed.
     * @return {?}
     */
    function (row) {
        if (!row.validator.valid) {
            return false;
        }
        var /** @type {?} */ source = this.rowsSubject.getValue();
        row.id = source.length - 1;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    };
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param row Row to be edited.
     */
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param {?} row Row to be edited.
     * @return {?}
     */
    TableDataSource.prototype.confirmEdit = /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param {?} row Row to be edited.
     * @return {?}
     */
    function (row) {
        if (!row.validator.valid) {
            return false;
        }
        var /** @type {?} */ source = this.rowsSubject.getValue();
        var /** @type {?} */ index = this.getIndexFromRowId(row.id, source);
        source[index] = row;
        this.rowsSubject.next(source);
        row.editing = false;
        row.validator.disable();
        this.updateDatasourceFromRows(source);
        return true;
    };
    /**
     * Delete the row with the index specified.
     */
    /**
     * Delete the row with the index specified.
     * @param {?} id
     * @return {?}
     */
    TableDataSource.prototype.delete = /**
     * Delete the row with the index specified.
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ source = this.rowsSubject.getValue();
        var /** @type {?} */ index = this.getIndexFromRowId(id, source);
        source.splice(index, 1);
        this.updateRowIds(index, source);
        this.rowsSubject.next(source);
        if (id != -1)
            this.updateDatasourceFromRows(source);
    };
    /**
   * Get row from the table.
   * @param id Id of the row to retrieve, -1 returns the current new line.
   */
    /**
     * Get row from the table.
     * @param {?} id Id of the row to retrieve, -1 returns the current new line.
     * @return {?}
     */
    TableDataSource.prototype.getRow = /**
     * Get row from the table.
     * @param {?} id Id of the row to retrieve, -1 returns the current new line.
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ source = this.rowsSubject.getValue();
        var /** @type {?} */ index = this.getIndexFromRowId(id, source);
        return (index >= 0 && index < source.length) ? source[index] : null;
    };
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param data Data to update the table datasource.
     * @param options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     */
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param {?} data Data to update the table datasource.
     * @param {?=} options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     * @return {?}
     */
    TableDataSource.prototype.updateDatasource = /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param {?} data Data to update the table datasource.
     * @param {?=} options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     * @return {?}
     */
    function (data, options) {
        if (options === void 0) { options = { emitEvent: true }; }
        if (this.currentData !== data) {
            this.currentData = data;
            this.rowsSubject.next(this.getRowsFromData(data));
            if (options.emitEvent)
                this.datasourceSubject.next(data);
        }
    };
    /**
     * Checks the existance of the a new row (not yet saved).
     * @param {?} source
     * @return {?}
     */
    TableDataSource.prototype.existsNewElement = /**
     * Checks the existance of the a new row (not yet saved).
     * @param {?} source
     * @return {?}
     */
    function (source) {
        return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
    };
    /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param {?} source
     * @return {?}
     */
    TableDataSource.prototype.getNewRowIndex = /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param {?} source
     * @return {?}
     */
    function (source) {
        if (this.config.prependNewElements)
            return 0;
        else
            return source.length - 1;
    };
    /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param {?} index Index of the array.
     * @param {?} count Quantity of elements in the array.
     * @return {?}
     */
    TableDataSource.prototype.getRowIdFromIndex = /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param {?} index Index of the array.
     * @param {?} count Quantity of elements in the array.
     * @return {?}
     */
    function (index, count) {
        if (this.config.prependNewElements)
            return count - 1 - index;
        else
            return index;
    };
    /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param {?} id
     * @param {?} source
     * @return {?}
     */
    TableDataSource.prototype.getIndexFromRowId = /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param {?} id
     * @param {?} source
     * @return {?}
     */
    function (id, source) {
        if (id == -1) {
            return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
        }
        else {
            if (this.config.prependNewElements)
                return source.length - 1 - id;
            else
                return id;
        }
    };
    /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param {?} initialIndex Initial index of source to be updated.
     * @param {?} source Array that contains the rows to be updated.
     * @return {?}
     */
    TableDataSource.prototype.updateRowIds = /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param {?} initialIndex Initial index of source to be updated.
     * @param {?} source Array that contains the rows to be updated.
     * @return {?}
     */
    function (initialIndex, source) {
        var /** @type {?} */ delta = this.config.prependNewElements ? -1 : 1;
        for (var /** @type {?} */ index = initialIndex; index < source.length && index >= 0; index += delta) {
            if (source[index].id != -1)
                source[index].id = this.getRowIdFromIndex(index, source.length);
        }
    };
    /**
     * Get the data from the rows.
     * @param {?} rows Rows to extract the data.
     * @return {?}
     */
    TableDataSource.prototype.getDataFromRows = /**
     * Get the data from the rows.
     * @param {?} rows Rows to extract the data.
     * @return {?}
     */
    function (rows) {
        return rows
            .filter(function (row) { return row.id != -1; })
            .map(function (row) {
            return row.originalData ? row.originalData : row.currentData;
        });
    };
    /**
     * Update the datasource with the data contained in the specified rows.
     * @param {?} rows Rows that contains the datasource's new data.
     * @return {?}
     */
    TableDataSource.prototype.updateDatasourceFromRows = /**
     * Update the datasource with the data contained in the specified rows.
     * @param {?} rows Rows that contains the datasource's new data.
     * @return {?}
     */
    function (rows) {
        this.currentData = this.getDataFromRows(rows);
        this.datasourceSubject.next(this.currentData);
    };
    /**
     * From an array of data, it returns rows containing the original data.
     * @param {?} arrayData Data from which create the rows.
     * @return {?}
     */
    TableDataSource.prototype.getRowsFromData = /**
     * From an array of data, it returns rows containing the original data.
     * @param {?} arrayData Data from which create the rows.
     * @return {?}
     */
    function (arrayData) {
        var _this = this;
        return arrayData.map(function (data, index) {
            return new TableElement({
                id: _this.getRowIdFromIndex(index, arrayData.length),
                editing: false,
                currentData: data,
                source: _this,
                validator: _this.validatorService.getRowValidator(),
            });
        });
    };
    /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     * @return {?}
     */
    TableDataSource.prototype.createNewObject = /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     * @return {?}
     */
    function () {
        if (this.dataConstructor)
            return new this.dataConstructor();
        else {
            return this.dataKeys.reduce(function (obj, key) {
                obj[key] = undefined;
                return obj;
            }, {});
        }
    };
    /** Connect function called by the table to retrieve one stream containing
     *  the data to render. */
    /**
     * Connect function called by the table to retrieve one stream containing
     *  the data to render.
     * @return {?}
     */
    TableDataSource.prototype.connect = /**
     * Connect function called by the table to retrieve one stream containing
     *  the data to render.
     * @return {?}
     */
    function () {
        return this.rowsSubject.asObservable();
    };
    /**
     * @return {?}
     */
    TableDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () { };
    return TableDataSource;
}(DataSource));
/**
 * @template T
 */
export { TableDataSource };
function TableDataSource_tsickle_Closure_declarations() {
    /** @type {?} */
    TableDataSource.prototype.rowsSubject;
    /** @type {?} */
    TableDataSource.prototype.datasourceSubject;
    /** @type {?} */
    TableDataSource.prototype.dataConstructor;
    /** @type {?} */
    TableDataSource.prototype.dataKeys;
    /** @type {?} */
    TableDataSource.prototype.currentData;
    /** @type {?} */
    TableDataSource.prototype.validatorService;
    /** @type {?} */
    TableDataSource.prototype.config;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZGF0YS1zb3VyY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS8iLCJzb3VyY2VzIjpbImxpYi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1kYXRhLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUVwRCxPQUFPLEVBQUMsZUFBZSxFQUFjLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUUxRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFFL0QsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0scURBQXFELENBQUM7Ozs7QUFHNUY7OztBQUFBO0lBQXdDLDJDQUEyQjtJQVVqRTs7Ozs7O09BTUc7SUFDSCx5QkFDRSxJQUFTLEVBQ1QsUUFBc0IsRUFDZCxrQkFDQTs0Q0FBVyxrQkFBa0IsRUFBRSxLQUFLO1FBSjlDLFlBTUUsaUJBQU8sU0FnQlI7UUFuQlMsc0JBQWdCLEdBQWhCLGdCQUFnQjtRQUNoQixZQUFNLEdBQU4sTUFBTTtRQUlkLEVBQUUsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7WUFDcEIsS0FBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksdUJBQXVCLEVBQUUsQ0FBQztRQUV4RCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsS0FBSSxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUM7U0FDakM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztnQkFDMUIsS0FBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUk7Z0JBQ0YsTUFBTSxJQUFJ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O1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDeEM7Ozs7SUFFRCxvQ0FBVTs7O0lBQVYsZUFBZ0I7MEJBdlNsQjtFQVN3QyxVQUFVLEVBK1JqRCxDQUFBOzs7O0FBL1JELDJCQStSQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGF0YVNvdXJjZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcclxuXHJcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7VGFibGVFbGVtZW50fSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWVsZW1lbnQnO1xyXG5pbXBvcnQge1ZhbGlkYXRvclNlcnZpY2V9IGZyb20gJy4vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtdmFsaWRhdG9yLnNlcnZpY2UnO1xyXG5pbXBvcnQge0RlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlfSBmcm9tICcuL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRlZmF1bHQtdmFsaWRhdG9yLnNlcnZpY2UnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBUYWJsZURhdGFTb3VyY2U8VD4gZXh0ZW5kcyBEYXRhU291cmNlPFRhYmxlRWxlbWVudDxUPj4ge1xyXG5cclxuICBwcml2YXRlIHJvd3NTdWJqZWN0OiBCZWhhdmlvclN1YmplY3Q8VGFibGVFbGVtZW50PFQ+W10+O1xyXG4gIGRhdGFzb3VyY2VTdWJqZWN0OiBTdWJqZWN0PFRbXT47XHJcblxyXG4gIHByaXZhdGUgZGF0YUNvbnN0cnVjdG9yOiBuZXcgKCkgPT4gVDtcclxuICBwcml2YXRlIGRhdGFLZXlzOiBhbnlbXTtcclxuXHJcbiAgcHJpdmF0ZSBjdXJyZW50RGF0YTogYW55O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFRhYmxlRGF0YVNvdXJjZSBpbnN0YW5jZSwgdGhhdCBjYW4gYmUgdXNlZCBhcyBkYXRhc291cmNlIG9mIGBAYW5ndWxhci9jZGtgIGRhdGEtdGFibGUuXHJcbiAgICogQHBhcmFtIGRhdGEgQXJyYXkgY29udGFpbmluZyB0aGUgaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBUYWJsZURhdGFTb3VyY2UuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYGRhdGFUeXBlYCBtdXN0IGJlIHNwZWNpZmllZC5cclxuICAgKiBAcGFyYW0gZGF0YVR5cGUgVHlwZSBvZiBkYXRhIGNvbnRhaW5lZCBieSB0aGUgVGFibGUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYGRhdGFgIHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQgbXVzdCBiZSBzcGVjaWZpZWQuXHJcbiAgICogQHBhcmFtIHZhbGlkYXRvclNlcnZpY2UgU2VydmljZSB0aGF0IGNyZWF0ZSBpbnN0YW5jZXMgb2YgdGhlIEZvcm1Hcm91cCB1c2VkIHRvIHZhbGlkYXRlIHJvdyBmaWVsZHMuXHJcbiAgICogQHBhcmFtIGNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRhYmxlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZGF0YTogVFtdLFxyXG4gICAgZGF0YVR5cGU/OiBuZXcgKCkgPT4gVCxcclxuICAgIHByaXZhdGUgdmFsaWRhdG9yU2VydmljZT86IFZhbGlkYXRvclNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGNvbmZpZyA9IHsgcHJlcGVuZE5ld0VsZW1lbnRzOiBmYWxzZSB9KVxyXG4gIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgaWYgKCF2YWxpZGF0b3JTZXJ2aWNlKVxyXG4gICAgICB0aGlzLnZhbGlkYXRvclNlcnZpY2UgPSBuZXcgRGVmYXVsdFZhbGlkYXRvclNlcnZpY2UoKTtcclxuXHJcbiAgICBpZiAoZGF0YVR5cGUpIHtcclxuICAgICAgdGhpcy5kYXRhQ29uc3RydWN0b3IgPSBkYXRhVHlwZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMClcclxuICAgICAgICB0aGlzLmRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGRlZmluZSBlaXRoZXIgYSBub24gZW1wdHkgYXJyYXksIG9yIGFuIGFzc29jaWF0ZWQgY2xhc3MgdG8gYnVpbGQgdGhlIHRhYmxlLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucm93c1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuZ2V0Um93c0Zyb21EYXRhKGRhdGEpKTtcclxuICAgIHRoaXMuZGF0YXNvdXJjZVN1YmplY3QgPSBuZXcgU3ViamVjdDxUW10+KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgY3JlYXRpb24gb2YgYSBuZXcgZWxlbWVudCwgcHVzaGluZyBhbiBlbXB0eS1kYXRhIHJvdyBpbiB0aGUgdGFibGUuXHJcbiAgICovXHJcbiAgY3JlYXRlTmV3KCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG5cclxuICAgIGlmICghdGhpcy5leGlzdHNOZXdFbGVtZW50KHNvdXJjZSkpIHtcclxuXHJcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBuZXcgVGFibGVFbGVtZW50KHtcclxuICAgICAgICBpZDogLTEsXHJcbiAgICAgICAgZWRpdGluZzogdHJ1ZSxcclxuICAgICAgICBjdXJyZW50RGF0YTogdGhpcy5jcmVhdGVOZXdPYmplY3QoKSxcclxuICAgICAgICBzb3VyY2U6IHRoaXMsXHJcbiAgICAgICAgdmFsaWRhdG9yOiB0aGlzLnZhbGlkYXRvclNlcnZpY2UuZ2V0Um93VmFsaWRhdG9yKCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cykge1xyXG4gICAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dChbbmV3RWxlbWVudF0uY29uY2F0KHNvdXJjZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNvdXJjZS5wdXNoKG5ld0VsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maXJtIGNyZWF0aW9uIG9mIHRoZSByb3cuIFNhdmUgY2hhbmdlcyBhbmQgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIElmIHZhbGlkYXRpb24gYWN0aXZlIGFuZCByb3cgZGF0YSBpcyBpbnZhbGlkLCBpdCBkb2Vzbid0IGNvbmZpcm0gY3JlYXRpb24gbmVpdGhlciBkaXNhYmxlIGVkaXRpbmcuXHJcbiAgICogQHBhcmFtIHJvdyBSb3cgdG8gYmUgY29uZmlybWVkLlxyXG4gICAqL1xyXG4gIGNvbmZpcm1DcmVhdGUocm93OiBUYWJsZUVsZW1lbnQ8VD4pOiBib29sZWFuIHtcclxuICAgIGlmICghcm93LnZhbGlkYXRvci52YWxpZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICByb3cuaWQgPSBzb3VyY2UubGVuZ3RoIC0gMTtcclxuICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xyXG5cclxuICAgIHJvdy5lZGl0aW5nID0gZmFsc2U7XHJcbiAgICByb3cudmFsaWRhdG9yLmRpc2FibGUoKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maXJtIGVkaXRpb24gb2YgdGhlIHJvdy4gU2F2ZSBjaGFuZ2VzIGFuZCBkaXNhYmxlIGVkaXRpbmcuXHJcbiAgICogSWYgdmFsaWRhdGlvbiBhY3RpdmUgYW5kIHJvdyBkYXRhIGlzIGludmFsaWQsIGl0IGRvZXNuJ3QgY29uZmlybSBlZGl0aW5nIG5laXRoZXIgZGlzYWJsZSBlZGl0aW5nLlxyXG4gICAqIEBwYXJhbSByb3cgUm93IHRvIGJlIGVkaXRlZC5cclxuICAgKi9cclxuICBjb25maXJtRWRpdChyb3c6IFRhYmxlRWxlbWVudDxUPik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKCFyb3cudmFsaWRhdG9yLnZhbGlkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQocm93LmlkLCBzb3VyY2UpO1xyXG5cclxuICAgIHNvdXJjZVtpbmRleF0gPSByb3c7XHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuXHJcbiAgICByb3cuZWRpdGluZyA9IGZhbHNlO1xyXG4gICAgcm93LnZhbGlkYXRvci5kaXNhYmxlKCk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVEYXRhc291cmNlRnJvbVJvd3Moc291cmNlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIHRoZSByb3cgd2l0aCB0aGUgaW5kZXggc3BlY2lmaWVkLlxyXG4gICAqL1xyXG4gIGRlbGV0ZShpZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQoaWQsIHNvdXJjZSk7XHJcblxyXG4gICAgc291cmNlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB0aGlzLnVwZGF0ZVJvd0lkcyhpbmRleCwgc291cmNlKTtcclxuXHJcbiAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQoc291cmNlKTtcclxuXHJcbiAgICBpZiAoaWQgIT0gLTEpXHJcbiAgICAgIHRoaXMudXBkYXRlRGF0YXNvdXJjZUZyb21Sb3dzKHNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICogR2V0IHJvdyBmcm9tIHRoZSB0YWJsZS5cclxuICogQHBhcmFtIGlkIElkIG9mIHRoZSByb3cgdG8gcmV0cmlldmUsIC0xIHJldHVybnMgdGhlIGN1cnJlbnQgbmV3IGxpbmUuXHJcbiAqL1xyXG4gIGdldFJvdyhpZDogbnVtYmVyKTogVGFibGVFbGVtZW50PFQ+IHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleEZyb21Sb3dJZChpZCwgc291cmNlKTtcclxuXHJcbiAgICByZXR1cm4gKGluZGV4ID49IDAgJiYgaW5kZXggPCBzb3VyY2UubGVuZ3RoKSA/IHNvdXJjZVtpbmRleF0gOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBkYXRhc291cmNlIHdpdGggYSBuZXcgYXJyYXkgb2YgZGF0YS4gSWYgdGhlIGFycmF5IHJlZmVyZW5jZVxyXG4gICAqIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBvbmUsIGl0IGRvZXNuJ3QgdHJpZ2dlciBhbiB1cGRhdGUuXHJcbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byB1cGRhdGUgdGhlIHRhYmxlIGRhdGFzb3VyY2UuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgU3BlY2lmeSBvcHRpb25zIHRvIHVwZGF0ZSB0aGUgZGF0YXNvdXJjZS5cclxuICAgKiBJZiBlbWl0RXZlbnQgaXMgdHJ1ZSBhbmQgdGhlIGRhdGFzb3VyY2UgaXMgdXBkYXRlZCwgaXQgZW1pdHMgYW4gZXZlbnRcclxuICAgKiBmcm9tICdkYXRhc291cmNlU3ViamVjdCcgd2l0aCB0aGUgdXBkYXRlZCBkYXRhLiBJZiBmYWxzZSwgaXQgZG9lc24ndFxyXG4gICAqIGVtaXQgYW4gZXZlbnQuIFRydWUgYnkgZGVmYXVsdC5cclxuICAgKi9cclxuICB1cGRhdGVEYXRhc291cmNlKGRhdGE6IFRbXSwgb3B0aW9ucyA9IHsgZW1pdEV2ZW50OiB0cnVlIH0pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmN1cnJlbnREYXRhICE9PSBkYXRhKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xyXG4gICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQodGhpcy5nZXRSb3dzRnJvbURhdGEoZGF0YSkpXHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5lbWl0RXZlbnQpXHJcbiAgICAgICAgdGhpcy5kYXRhc291cmNlU3ViamVjdC5uZXh0KGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB0aGUgZXhpc3RhbmNlIG9mIHRoZSBhIG5ldyByb3cgKG5vdCB5ZXQgc2F2ZWQpLlxyXG4gICAqIEBwYXJhbSBzb3VyY2VcclxuICAgKi9cclxuICBwcml2YXRlIGV4aXN0c05ld0VsZW1lbnQoc291cmNlOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gIShzb3VyY2UubGVuZ3RoID09IDAgfHwgc291cmNlW3RoaXMuZ2V0TmV3Um93SW5kZXgoc291cmNlKV0uaWQgPiAtMSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHBvc3NpYmxlIGluZGV4IG9mIHRoZSBuZXcgcm93IGRlcGVuZGluZyBvbiB0aGUgaW5zZXJ0aW9uIHR5cGUuXHJcbiAgICogSXQgZG9lc24ndCBpbXBseSB0aGF0IHRoZSBuZXcgcm93IGlzIGNyZWF0ZWQsIHRoYXQgbXVzdCBiZSBjaGVja2VkLlxyXG4gICAqIEBwYXJhbSBzb3VyY2VcclxuICAgKi9cclxuICBwcml2YXRlIGdldE5ld1Jvd0luZGV4KHNvdXJjZSk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIHNvdXJjZS5sZW5ndGggLSAxO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcm93IGlkIGZyb20gdGhlIGluZGV4IHNwZWNpZmllZC4gSXQgZG9lc1xyXG4gICAqIG5vdCBjb25zaWRlciBpZiB0aGUgbmV3IHJvdyBpcyBwcmVzZW50IG9yIG5vdCwgYXNzdW1lc1xyXG4gICAqIHRoYXQgbmV3IHJvdyBpcyBub3QgcHJlc2VudC5cclxuICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGFycmF5LlxyXG4gICAqIEBwYXJhbSBjb3VudCBRdWFudGl0eSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRSb3dJZEZyb21JbmRleChpbmRleDogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXHJcbiAgICAgIHJldHVybiBjb3VudCAtIDEgLSBpbmRleDtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW5kZXggZnJvbSB0aGUgcm93IGlkIHNwZWNpZmllZC5cclxuICAgKiBJdCB0YWtlcyBpbnRvIGFjY291bnQgaWYgdGhlIG5ldyByb3cgZXhpc3RzIG9yIG5vdC5cclxuICAgKiBAcGFyYW0gaWRcclxuICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRJbmRleEZyb21Sb3dJZChpZDogbnVtYmVyLCBzb3VyY2U6IFRhYmxlRWxlbWVudDxUPltdKTogbnVtYmVyIHtcclxuICAgIGlmKGlkID09IC0xKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmV4aXN0c05ld0VsZW1lbnQoc291cmNlKSA/IHRoaXMuZ2V0TmV3Um93SW5kZXgoc291cmNlKSA6IC0xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cylcclxuICAgICAgICAgIHJldHVybiBzb3VyY2UubGVuZ3RoIC0gMSAtIGlkO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHJvd3MgaWRzIGluIHRoZSBhcnJheSBzcGVjaWZpZWQsIHN0YXJ0aW5nIGluIHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgKiB1bnRpbCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBhcnJheSwgZGVwZW5kaW5nIG9uIGNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHNcclxuICAgKiBjb25maWd1cmF0aW9uLlxyXG4gICAqIEBwYXJhbSBpbml0aWFsSW5kZXggSW5pdGlhbCBpbmRleCBvZiBzb3VyY2UgdG8gYmUgdXBkYXRlZC5cclxuICAgKiBAcGFyYW0gc291cmNlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJvd3MgdG8gYmUgdXBkYXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZVJvd0lkcyhpbml0aWFsSW5kZXg6IG51bWJlciwgc291cmNlOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzID8gLTEgOiAxO1xyXG5cclxuICAgIGZvciAobGV0IGluZGV4ID0gaW5pdGlhbEluZGV4OyBpbmRleCA8IHNvdXJjZS5sZW5ndGggJiYgaW5kZXggPj0gMDsgaW5kZXggKz0gZGVsdGEpIHtcclxuICAgICAgaWYgKHNvdXJjZVtpbmRleF0uaWQgIT0gLTEpXHJcbiAgICAgICAgc291cmNlW2luZGV4XS5pZCA9IHRoaXMuZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXgsIHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIHJvd3MuXHJcbiAgICogQHBhcmFtIHJvd3MgUm93cyB0byBleHRyYWN0IHRoZSBkYXRhLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0RGF0YUZyb21Sb3dzKHJvd3M6IFRhYmxlRWxlbWVudDxUPltdKTogVFtdIHtcclxuICAgIHJldHVybiByb3dzXHJcbiAgICAgIC5maWx0ZXIocm93ID0+IHJvdy5pZCAhPSAtMSlcclxuICAgICAgLm1hcDxUPigocm93KSA9PiB7XHJcbiAgICAgIHJldHVybiByb3cub3JpZ2luYWxEYXRhID8gcm93Lm9yaWdpbmFsRGF0YSA6IHJvdy5jdXJyZW50RGF0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBkYXRhc291cmNlIHdpdGggdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBzcGVjaWZpZWQgcm93cy5cclxuICAgKiBAcGFyYW0gcm93cyBSb3dzIHRoYXQgY29udGFpbnMgdGhlIGRhdGFzb3VyY2UncyBuZXcgZGF0YS5cclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhyb3dzOiBUYWJsZUVsZW1lbnQ8VD5bXSk6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Sb3dzKHJvd3MpO1xyXG4gICAgdGhpcy5kYXRhc291cmNlU3ViamVjdC5uZXh0KHRoaXMuY3VycmVudERhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJvbSBhbiBhcnJheSBvZiBkYXRhLCBpdCByZXR1cm5zIHJvd3MgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgZGF0YS5cclxuICAgKiBAcGFyYW0gYXJyYXlEYXRhIERhdGEgZnJvbSB3aGljaCBjcmVhdGUgdGhlIHJvd3MuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRSb3dzRnJvbURhdGEoYXJyYXlEYXRhOiBUW10pOiBUYWJsZUVsZW1lbnQ8VD5bXSB7XHJcbiAgICByZXR1cm4gYXJyYXlEYXRhLm1hcDxUYWJsZUVsZW1lbnQ8VD4+KChkYXRhLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFRhYmxlRWxlbWVudCh7XHJcbiAgICAgICAgaWQ6IHRoaXMuZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXgsIGFycmF5RGF0YS5sZW5ndGgpLFxyXG4gICAgICAgIGVkaXRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGN1cnJlbnREYXRhOiBkYXRhLFxyXG4gICAgICAgIHNvdXJjZTogdGhpcyxcclxuICAgICAgICB2YWxpZGF0b3I6IHRoaXMudmFsaWRhdG9yU2VydmljZS5nZXRSb3dWYWxpZGF0b3IoKSxcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIGlkZW50aWNhbCBzdHJ1Y3R1cmUgdGhhbiB0aGUgdGFibGUgc291cmNlIGRhdGEuXHJcbiAgICogSXQgdXNlcyB0aGUgb2JqZWN0J3MgdHlwZSBjb250cnVjdG9yIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGl0IGNyZWF0ZXNcclxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5lZCBpbiB0aGUgb3JpZ2luYWxcclxuICAgKiBkYXRhc291cmNlICh1c2VkIGluIHRoZSBjb25zdHJ1Y3RvcikuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVOZXdPYmplY3QoKTogVCB7XHJcbiAgICBpZiAodGhpcy5kYXRhQ29uc3RydWN0b3IpXHJcbiAgICAgIHJldHVybiBuZXcgdGhpcy5kYXRhQ29uc3RydWN0b3IoKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhS2V5cy5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XHJcbiAgICAgICAgb2JqW2tleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSwge30pO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8qKiBDb25uZWN0IGZ1bmN0aW9uIGNhbGxlZCBieSB0aGUgdGFibGUgdG8gcmV0cmlldmUgb25lIHN0cmVhbSBjb250YWluaW5nXHJcbiAgICogIHRoZSBkYXRhIHRvIHJlbmRlci4gKi9cclxuICBjb25uZWN0KCk6IE9ic2VydmFibGU8VGFibGVFbGVtZW50PFQ+W10+IHtcclxuICAgIHJldHVybiB0aGlzLnJvd3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgZGlzY29ubmVjdCgpIHsgfVxyXG59XHJcbiJdfQ==