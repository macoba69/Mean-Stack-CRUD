(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash.clonedeep'), require('@angular/core'), require('@angular/forms'), require('tslib'), require('@angular/cdk/collections'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('angular6-material-table', ['exports', 'lodash.clonedeep', '@angular/core', '@angular/forms', 'tslib', '@angular/cdk/collections', 'rxjs'], factory) :
    (factory((global['angular6-material-table'] = {}),null,global.ng.core,global.ng.forms,global.tslib,global.ng.cdk.collections,null));
}(this, (function (exports,cloneDeep,core,forms,tslib_1,collections,rxjs) { 'use strict';

    cloneDeep = cloneDeep && cloneDeep.hasOwnProperty('default') ? cloneDeep['default'] : cloneDeep;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ TableElement = (function () {
        function TableElement(init) {
            Object.assign(this, init);
            this.fillValidatorFromData();
            if (this.validator) {
                if (this.editing) {
                    this.validator.enable();
                }
                else {
                    this.validator.disable();
                }
            }
        }
        Object.defineProperty(TableElement.prototype, "currentData", {
            get: /**
             * @return {?}
             */ function () {
                //express hack
                if (this.validator) {
                    return Object.assign(this._currentData, this.validator.getRawValue());
                }
                else {
                    return this._currentData;
                }
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._currentData = value;
                this.fillValidatorFromData();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TableElement.prototype.fillValidatorFromData = /**
         * @return {?}
         */
            function () {
                if (this.validator) {
                    var /** @type {?} */ formData = {};
                    for (var /** @type {?} */ key in this.validator.controls) {
                        formData[key] = this._currentData[key];
                    }
                    this.validator.setValue(formData);
                }
            };
        /**
         * @return {?}
         */
        TableElement.prototype.delete = /**
         * @return {?}
         */
            function () {
                this.source.delete(this.id);
            };
        /**
         * @return {?}
         */
        TableElement.prototype.confirmEditCreate = /**
         * @return {?}
         */
            function () {
                this.originalData = undefined;
                if (this.id == -1)
                    return this.source.confirmCreate(this);
                else
                    return this.source.confirmEdit(this);
            };
        /**
         * @return {?}
         */
        TableElement.prototype.startEdit = /**
         * @return {?}
         */
            function () {
                this.originalData = cloneDeep(this.currentData);
                this.editing = true;
                this.validator.enable();
            };
        /**
         * @return {?}
         */
        TableElement.prototype.cancelOrDelete = /**
         * @return {?}
         */
            function () {
                if (this.id == -1 || !this.editing)
                    this.delete();
                else {
                    this.currentData = this.originalData;
                    this.editing = false;
                    this.validator.disable();
                }
            };
        return TableElement;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DefaultValidatorService = (function () {
        function DefaultValidatorService() {
        }
        /**
         * @return {?}
         */
        DefaultValidatorService.prototype.getRowValidator = /**
         * @return {?}
         */
            function () {
                return new forms.FormGroup({});
            };
        DefaultValidatorService.decorators = [
            { type: core.Injectable },
        ];
        return DefaultValidatorService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ TableDataSource = (function (_super) {
        tslib_1.__extends(TableDataSource, _super);
        /**
         * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.
         * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
         * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
         * @param validatorService Service that create instances of the FormGroup used to validate row fields.
         * @param config Additional configuration for table.
         */
        function TableDataSource(data, dataType, validatorService, config) {
            if (config === void 0) {
                config = { prependNewElements: false };
            }
            var _this = _super.call(this) || this;
            _this.validatorService = validatorService;
            _this.config = config;
            if (!validatorService)
                _this.validatorService = new DefaultValidatorService();
            if (dataType) {
                _this.dataConstructor = dataType;
            }
            else {
                if (data && data.length > 0)
                    _this.dataKeys = Object.keys(data[0]);
                else
                    throw new Error('You must define either a non empty array, or an associated class to build the table.');
            }
            _this.rowsSubject = new rxjs.BehaviorSubject(_this.getRowsFromData(data));
            _this.datasourceSubject = new rxjs.Subject();
            return _this;
        }
        /**
         * Start the creation of a new element, pushing an empty-data row in the table.
         */
        /**
         * Start the creation of a new element, pushing an empty-data row in the table.
         * @return {?}
         */
        TableDataSource.prototype.createNew = /**
         * Start the creation of a new element, pushing an empty-data row in the table.
         * @return {?}
         */
            function () {
                var /** @type {?} */ source = this.rowsSubject.getValue();
                if (!this.existsNewElement(source)) {
                    var /** @type {?} */ newElement = new TableElement({
                        id: -1,
                        editing: true,
                        currentData: this.createNewObject(),
                        source: this,
                        validator: this.validatorService.getRowValidator(),
                    });
                    if (this.config.prependNewElements) {
                        this.rowsSubject.next([newElement].concat(source));
                    }
                    else {
                        source.push(newElement);
                        this.rowsSubject.next(source);
                    }
                }
            };
        /**
         * Confirm creation of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
         * @param row Row to be confirmed.
         */
        /**
         * Confirm creation of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
         * @param {?} row Row to be confirmed.
         * @return {?}
         */
        TableDataSource.prototype.confirmCreate = /**
         * Confirm creation of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
         * @param {?} row Row to be confirmed.
         * @return {?}
         */
            function (row) {
                if (!row.validator.valid) {
                    return false;
                }
                var /** @type {?} */ source = this.rowsSubject.getValue();
                row.id = source.length - 1;
                this.rowsSubject.next(source);
                row.editing = false;
                row.validator.disable();
                this.updateDatasourceFromRows(source);
                return true;
            };
        /**
         * Confirm edition of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
         * @param row Row to be edited.
         */
        /**
         * Confirm edition of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
         * @param {?} row Row to be edited.
         * @return {?}
         */
        TableDataSource.prototype.confirmEdit = /**
         * Confirm edition of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
         * @param {?} row Row to be edited.
         * @return {?}
         */
            function (row) {
                if (!row.validator.valid) {
                    return false;
                }
                var /** @type {?} */ source = this.rowsSubject.getValue();
                var /** @type {?} */ index = this.getIndexFromRowId(row.id, source);
                source[index] = row;
                this.rowsSubject.next(source);
                row.editing = false;
                row.validator.disable();
                this.updateDatasourceFromRows(source);
                return true;
            };
        /**
         * Delete the row with the index specified.
         */
        /**
         * Delete the row with the index specified.
         * @param {?} id
         * @return {?}
         */
        TableDataSource.prototype.delete = /**
         * Delete the row with the index specified.
         * @param {?} id
         * @return {?}
         */
            function (id) {
                var /** @type {?} */ source = this.rowsSubject.getValue();
                var /** @type {?} */ index = this.getIndexFromRowId(id, source);
                source.splice(index, 1);
                this.updateRowIds(index, source);
                this.rowsSubject.next(source);
                if (id != -1)
                    this.updateDatasourceFromRows(source);
            };
        /**
       * Get row from the table.
       * @param id Id of the row to retrieve, -1 returns the current new line.
       */
        /**
         * Get row from the table.
         * @param {?} id Id of the row to retrieve, -1 returns the current new line.
         * @return {?}
         */
        TableDataSource.prototype.getRow = /**
         * Get row from the table.
         * @param {?} id Id of the row to retrieve, -1 returns the current new line.
         * @return {?}
         */
            function (id) {
                var /** @type {?} */ source = this.rowsSubject.getValue();
                var /** @type {?} */ index = this.getIndexFromRowId(id, source);
                return (index >= 0 && index < source.length) ? source[index] : null;
            };
        /**
         * Update the datasource with a new array of data. If the array reference
         * is the same as the previous one, it doesn't trigger an update.
         * @param data Data to update the table datasource.
         * @param options Specify options to update the datasource.
         * If emitEvent is true and the datasource is updated, it emits an event
         * from 'datasourceSubject' with the updated data. If false, it doesn't
         * emit an event. True by default.
         */
        /**
         * Update the datasource with a new array of data. If the array reference
         * is the same as the previous one, it doesn't trigger an update.
         * @param {?} data Data to update the table datasource.
         * @param {?=} options Specify options to update the datasource.
         * If emitEvent is true and the datasource is updated, it emits an event
         * from 'datasourceSubject' with the updated data. If false, it doesn't
         * emit an event. True by default.
         * @return {?}
         */
        TableDataSource.prototype.updateDatasource = /**
         * Update the datasource with a new array of data. If the array reference
         * is the same as the previous one, it doesn't trigger an update.
         * @param {?} data Data to update the table datasource.
         * @param {?=} options Specify options to update the datasource.
         * If emitEvent is true and the datasource is updated, it emits an event
         * from 'datasourceSubject' with the updated data. If false, it doesn't
         * emit an event. True by default.
         * @return {?}
         */
            function (data, options) {
                if (options === void 0) {
                    options = { emitEvent: true };
                }
                if (this.currentData !== data) {
                    this.currentData = data;
                    this.rowsSubject.next(this.getRowsFromData(data));
                    if (options.emitEvent)
                        this.datasourceSubject.next(data);
                }
            };
        /**
         * Checks the existance of the a new row (not yet saved).
         * @param {?} source
         * @return {?}
         */
        TableDataSource.prototype.existsNewElement = /**
         * Checks the existance of the a new row (not yet saved).
         * @param {?} source
         * @return {?}
         */
            function (source) {
                return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
            };
        /**
         * Returns the possible index of the new row depending on the insertion type.
         * It doesn't imply that the new row is created, that must be checked.
         * @param {?} source
         * @return {?}
         */
        TableDataSource.prototype.getNewRowIndex = /**
         * Returns the possible index of the new row depending on the insertion type.
         * It doesn't imply that the new row is created, that must be checked.
         * @param {?} source
         * @return {?}
         */
            function (source) {
                if (this.config.prependNewElements)
                    return 0;
                else
                    return source.length - 1;
            };
        /**
         * Returns the row id from the index specified. It does
         * not consider if the new row is present or not, assumes
         * that new row is not present.
         * @param {?} index Index of the array.
         * @param {?} count Quantity of elements in the array.
         * @return {?}
         */
        TableDataSource.prototype.getRowIdFromIndex = /**
         * Returns the row id from the index specified. It does
         * not consider if the new row is present or not, assumes
         * that new row is not present.
         * @param {?} index Index of the array.
         * @param {?} count Quantity of elements in the array.
         * @return {?}
         */
            function (index, count) {
                if (this.config.prependNewElements)
                    return count - 1 - index;
                else
                    return index;
            };
        /**
         * Returns the index from the row id specified.
         * It takes into account if the new row exists or not.
         * @param {?} id
         * @param {?} source
         * @return {?}
         */
        TableDataSource.prototype.getIndexFromRowId = /**
         * Returns the index from the row id specified.
         * It takes into account if the new row exists or not.
         * @param {?} id
         * @param {?} source
         * @return {?}
         */
            function (id, source) {
                if (id == -1) {
                    return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
                }
                else {
                    if (this.config.prependNewElements)
                        return source.length - 1 - id;
                    else
                        return id;
                }
            };
        /**
         * Update rows ids in the array specified, starting in the specified index
         * until the start/end of the array, depending on config.prependNewElements
         * configuration.
         * @param {?} initialIndex Initial index of source to be updated.
         * @param {?} source Array that contains the rows to be updated.
         * @return {?}
         */
        TableDataSource.prototype.updateRowIds = /**
         * Update rows ids in the array specified, starting in the specified index
         * until the start/end of the array, depending on config.prependNewElements
         * configuration.
         * @param {?} initialIndex Initial index of source to be updated.
         * @param {?} source Array that contains the rows to be updated.
         * @return {?}
         */
            function (initialIndex, source) {
                var /** @type {?} */ delta = this.config.prependNewElements ? -1 : 1;
                for (var /** @type {?} */ index = initialIndex; index < source.length && index >= 0; index += delta) {
                    if (source[index].id != -1)
                        source[index].id = this.getRowIdFromIndex(index, source.length);
                }
            };
        /**
         * Get the data from the rows.
         * @param {?} rows Rows to extract the data.
         * @return {?}
         */
        TableDataSource.prototype.getDataFromRows = /**
         * Get the data from the rows.
         * @param {?} rows Rows to extract the data.
         * @return {?}
         */
            function (rows) {
                return rows
                    .filter(function (row) { return row.id != -1; })
                    .map(function (row) {
                    return row.originalData ? row.originalData : row.currentData;
                });
            };
        /**
         * Update the datasource with the data contained in the specified rows.
         * @param {?} rows Rows that contains the datasource's new data.
         * @return {?}
         */
        TableDataSource.prototype.updateDatasourceFromRows = /**
         * Update the datasource with the data contained in the specified rows.
         * @param {?} rows Rows that contains the datasource's new data.
         * @return {?}
         */
            function (rows) {
                this.currentData = this.getDataFromRows(rows);
                this.datasourceSubject.next(this.currentData);
            };
        /**
         * From an array of data, it returns rows containing the original data.
         * @param {?} arrayData Data from which create the rows.
         * @return {?}
         */
        TableDataSource.prototype.getRowsFromData = /**
         * From an array of data, it returns rows containing the original data.
         * @param {?} arrayData Data from which create the rows.
         * @return {?}
         */
            function (arrayData) {
                var _this = this;
                return arrayData.map(function (data, index) {
                    return new TableElement({
                        id: _this.getRowIdFromIndex(index, arrayData.length),
                        editing: false,
                        currentData: data,
                        source: _this,
                        validator: _this.validatorService.getRowValidator(),
                    });
                });
            };
        /**
         * Create a new object with identical structure than the table source data.
         * It uses the object's type contructor if available, otherwise it creates
         * an object with the same keys of the first element contained in the original
         * datasource (used in the constructor).
         * @return {?}
         */
        TableDataSource.prototype.createNewObject = /**
         * Create a new object with identical structure than the table source data.
         * It uses the object's type contructor if available, otherwise it creates
         * an object with the same keys of the first element contained in the original
         * datasource (used in the constructor).
         * @return {?}
         */
            function () {
                if (this.dataConstructor)
                    return new this.dataConstructor();
                else {
                    return this.dataKeys.reduce(function (obj, key) {
                        obj[key] = undefined;
                        return obj;
                    }, {});
                }
            };
        /** Connect function called by the table to retrieve one stream containing
         *  the data to render. */
        /**
         * Connect function called by the table to retrieve one stream containing
         *  the data to render.
         * @return {?}
         */
        TableDataSource.prototype.connect = /**
         * Connect function called by the table to retrieve one stream containing
         *  the data to render.
         * @return {?}
         */
            function () {
                return this.rowsSubject.asObservable();
            };
        /**
         * @return {?}
         */
        TableDataSource.prototype.disconnect = /**
         * @return {?}
         */
            function () { };
        return TableDataSource;
    }(collections.DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var ValidatorService = (function () {
        function ValidatorService() {
        }
        ValidatorService.decorators = [
            { type: core.Injectable },
        ];
        return ValidatorService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.TableDataSource = TableDataSource;
    exports.DefaultValidatorService = DefaultValidatorService;
    exports.TableElement = TableElement;
    exports.ValidatorService = ValidatorService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS9saWIvYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZWxlbWVudC50cyIsIm5nOi8vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUvbGliL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLWRlZmF1bHQtdmFsaWRhdG9yLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlL2xpYi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1kYXRhLXNvdXJjZS50cyIsIm5nOi8vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUvbGliL2FuZ3VsYXI2LW1hdGVyaWFsLXRhYmxlLXZhbGlkYXRvci5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Rm9ybUdyb3VwfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQge1RhYmxlRGF0YVNvdXJjZX0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS1kYXRhLXNvdXJjZSc7XHJcblxyXG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC5jbG9uZWRlZXAnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRhYmxlRWxlbWVudDxUPiB7XHJcbiAgaWQ6IG51bWJlcjtcclxuICBlZGl0aW5nOiBib29sZWFuO1xyXG4gIHByaXZhdGUgX2N1cnJlbnREYXRhPzogVDtcclxuICBvcmlnaW5hbERhdGE6IFQ7XHJcbiAgc291cmNlOiBUYWJsZURhdGFTb3VyY2U8VD47XHJcbiAgdmFsaWRhdG9yOiBGb3JtR3JvdXA7XHJcbiAgZ2V0IGN1cnJlbnREYXRhKCkge1xyXG4gICAgLy9leHByZXNzIGhhY2tcclxuICAgIGlmICh0aGlzLnZhbGlkYXRvcikge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLl9jdXJyZW50RGF0YSwgdGhpcy52YWxpZGF0b3IuZ2V0UmF3VmFsdWUoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudERhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgY3VycmVudERhdGEodmFsdWUpIHtcclxuICAgIHRoaXMuX2N1cnJlbnREYXRhID0gdmFsdWU7XHJcbiAgICB0aGlzLmZpbGxWYWxpZGF0b3JGcm9tRGF0YSgpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoaW5pdDogUGFydGlhbDxUYWJsZUVsZW1lbnQ8VD4+KSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXQpO1xyXG4gICAgdGhpcy5maWxsVmFsaWRhdG9yRnJvbURhdGEoKTtcclxuICAgIGlmICh0aGlzLnZhbGlkYXRvcikge1xyXG4gICAgICBpZiAodGhpcy5lZGl0aW5nKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IuZW5hYmxlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IuZGlzYWJsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmaWxsVmFsaWRhdG9yRnJvbURhdGEoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy52YWxpZGF0b3IpIHtcclxuICAgICAgbGV0IGZvcm1EYXRhID0ge307XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnZhbGlkYXRvci5jb250cm9scykge1xyXG4gICAgICAgIGZvcm1EYXRhW2tleV0gPSB0aGlzLl9jdXJyZW50RGF0YVtrZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudmFsaWRhdG9yLnNldFZhbHVlKGZvcm1EYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlbGV0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuc291cmNlLmRlbGV0ZSh0aGlzLmlkKTtcclxuICB9XHJcblxyXG4gIGNvbmZpcm1FZGl0Q3JlYXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgdGhpcy5vcmlnaW5hbERhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAodGhpcy5pZCA9PSAtMSlcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbmZpcm1DcmVhdGUodGhpcyk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jb25maXJtRWRpdCh0aGlzKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0RWRpdCgpOiB2b2lkIHtcclxuICAgIHRoaXMub3JpZ2luYWxEYXRhID0gY2xvbmVEZWVwKHRoaXMuY3VycmVudERhdGEpO1xyXG4gICAgdGhpcy5lZGl0aW5nID0gdHJ1ZTtcclxuICAgIHRoaXMudmFsaWRhdG9yLmVuYWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgY2FuY2VsT3JEZWxldGUoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5pZCA9PSAtMSB8fCAhdGhpcy5lZGl0aW5nKVxyXG4gICAgICB0aGlzLmRlbGV0ZSgpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMuY3VycmVudERhdGEgPSB0aGlzLm9yaWdpbmFsRGF0YTtcclxuICAgICAgdGhpcy5lZGl0aW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudmFsaWRhdG9yLmRpc2FibGUoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQgeyBWYWxpZGF0b3JTZXJ2aWNlIH0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS12YWxpZGF0b3Iuc2VydmljZSc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0VmFsaWRhdG9yU2VydmljZSBpbXBsZW1lbnRzIFZhbGlkYXRvclNlcnZpY2Uge1xyXG5cclxuICBnZXRSb3dWYWxpZGF0b3IoKTogRm9ybUdyb3VwIHtcclxuICAgIHJldHVybiBuZXcgRm9ybUdyb3VwKHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtEYXRhU291cmNlfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xyXG5cclxuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHtUYWJsZUVsZW1lbnR9IGZyb20gJy4vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZWxlbWVudCc7XHJcbmltcG9ydCB7VmFsaWRhdG9yU2VydmljZX0gZnJvbSAnLi9hbmd1bGFyNi1tYXRlcmlhbC10YWJsZS12YWxpZGF0b3Iuc2VydmljZSc7XHJcbmltcG9ydCB7RGVmYXVsdFZhbGlkYXRvclNlcnZpY2V9IGZyb20gJy4vYW5ndWxhcjYtbWF0ZXJpYWwtdGFibGUtZGVmYXVsdC12YWxpZGF0b3Iuc2VydmljZSc7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFRhYmxlRGF0YVNvdXJjZTxUPiBleHRlbmRzIERhdGFTb3VyY2U8VGFibGVFbGVtZW50PFQ+PiB7XHJcblxyXG4gIHByaXZhdGUgcm93c1N1YmplY3Q6IEJlaGF2aW9yU3ViamVjdDxUYWJsZUVsZW1lbnQ8VD5bXT47XHJcbiAgZGF0YXNvdXJjZVN1YmplY3Q6IFN1YmplY3Q8VFtdPjtcclxuXHJcbiAgcHJpdmF0ZSBkYXRhQ29uc3RydWN0b3I6IG5ldyAoKSA9PiBUO1xyXG4gIHByaXZhdGUgZGF0YUtleXM6IGFueVtdO1xyXG5cclxuICBwcml2YXRlIGN1cnJlbnREYXRhOiBhbnk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgVGFibGVEYXRhU291cmNlIGluc3RhbmNlLCB0aGF0IGNhbiBiZSB1c2VkIGFzIGRhdGFzb3VyY2Ugb2YgYEBhbmd1bGFyL2Nka2AgZGF0YS10YWJsZS5cclxuICAgKiBAcGFyYW0gZGF0YSBBcnJheSBjb250YWluaW5nIHRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIFRhYmxlRGF0YVNvdXJjZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlbiBgZGF0YVR5cGVgIG11c3QgYmUgc3BlY2lmaWVkLlxyXG4gICAqIEBwYXJhbSBkYXRhVHlwZSBUeXBlIG9mIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBUYWJsZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlbiBgZGF0YWAgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudCBtdXN0IGJlIHNwZWNpZmllZC5cclxuICAgKiBAcGFyYW0gdmFsaWRhdG9yU2VydmljZSBTZXJ2aWNlIHRoYXQgY3JlYXRlIGluc3RhbmNlcyBvZiB0aGUgRm9ybUdyb3VwIHVzZWQgdG8gdmFsaWRhdGUgcm93IGZpZWxkcy5cclxuICAgKiBAcGFyYW0gY29uZmlnIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGFibGUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBkYXRhOiBUW10sXHJcbiAgICBkYXRhVHlwZT86IG5ldyAoKSA9PiBULFxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3JTZXJ2aWNlPzogVmFsaWRhdG9yU2VydmljZSxcclxuICAgIHByaXZhdGUgY29uZmlnID0geyBwcmVwZW5kTmV3RWxlbWVudHM6IGZhbHNlIH0pXHJcbiAge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRvclNlcnZpY2UpXHJcbiAgICAgIHRoaXMudmFsaWRhdG9yU2VydmljZSA9IG5ldyBEZWZhdWx0VmFsaWRhdG9yU2VydmljZSgpO1xyXG5cclxuICAgIGlmIChkYXRhVHlwZSkge1xyXG4gICAgICB0aGlzLmRhdGFDb25zdHJ1Y3RvciA9IGRhdGFUeXBlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHRoaXMuZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGVpdGhlciBhIG5vbiBlbXB0eSBhcnJheSwgb3IgYW4gYXNzb2NpYXRlZCBjbGFzcyB0byBidWlsZCB0aGUgdGFibGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yb3dzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodGhpcy5nZXRSb3dzRnJvbURhdGEoZGF0YSkpO1xyXG4gICAgdGhpcy5kYXRhc291cmNlU3ViamVjdCA9IG5ldyBTdWJqZWN0PFRbXT4oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBjcmVhdGlvbiBvZiBhIG5ldyBlbGVtZW50LCBwdXNoaW5nIGFuIGVtcHR5LWRhdGEgcm93IGluIHRoZSB0YWJsZS5cclxuICAgKi9cclxuICBjcmVhdGVOZXcoKTogdm9pZCB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmV4aXN0c05ld0VsZW1lbnQoc291cmNlKSkge1xyXG5cclxuICAgICAgY29uc3QgbmV3RWxlbWVudCA9IG5ldyBUYWJsZUVsZW1lbnQoe1xyXG4gICAgICAgIGlkOiAtMSxcclxuICAgICAgICBlZGl0aW5nOiB0cnVlLFxyXG4gICAgICAgIGN1cnJlbnREYXRhOiB0aGlzLmNyZWF0ZU5ld09iamVjdCgpLFxyXG4gICAgICAgIHNvdXJjZTogdGhpcyxcclxuICAgICAgICB2YWxpZGF0b3I6IHRoaXMudmFsaWRhdG9yU2VydmljZS5nZXRSb3dWYWxpZGF0b3IoKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KFtuZXdFbGVtZW50XS5jb25jYXQoc291cmNlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc291cmNlLnB1c2gobmV3RWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbmZpcm0gY3JlYXRpb24gb2YgdGhlIHJvdy4gU2F2ZSBjaGFuZ2VzIGFuZCBkaXNhYmxlIGVkaXRpbmcuXHJcbiAgICogSWYgdmFsaWRhdGlvbiBhY3RpdmUgYW5kIHJvdyBkYXRhIGlzIGludmFsaWQsIGl0IGRvZXNuJ3QgY29uZmlybSBjcmVhdGlvbiBuZWl0aGVyIGRpc2FibGUgZWRpdGluZy5cclxuICAgKiBAcGFyYW0gcm93IFJvdyB0byBiZSBjb25maXJtZWQuXHJcbiAgICovXHJcbiAgY29uZmlybUNyZWF0ZShyb3c6IFRhYmxlRWxlbWVudDxUPik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKCFyb3cudmFsaWRhdG9yLnZhbGlkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuICAgIHJvdy5pZCA9IHNvdXJjZS5sZW5ndGggLSAxO1xyXG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XHJcblxyXG4gICAgcm93LmVkaXRpbmcgPSBmYWxzZTtcclxuICAgIHJvdy52YWxpZGF0b3IuZGlzYWJsZSgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRGF0YXNvdXJjZUZyb21Sb3dzKHNvdXJjZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbmZpcm0gZWRpdGlvbiBvZiB0aGUgcm93LiBTYXZlIGNoYW5nZXMgYW5kIGRpc2FibGUgZWRpdGluZy5cclxuICAgKiBJZiB2YWxpZGF0aW9uIGFjdGl2ZSBhbmQgcm93IGRhdGEgaXMgaW52YWxpZCwgaXQgZG9lc24ndCBjb25maXJtIGVkaXRpbmcgbmVpdGhlciBkaXNhYmxlIGVkaXRpbmcuXHJcbiAgICogQHBhcmFtIHJvdyBSb3cgdG8gYmUgZWRpdGVkLlxyXG4gICAqL1xyXG4gIGNvbmZpcm1FZGl0KHJvdzogVGFibGVFbGVtZW50PFQ+KTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXJvdy52YWxpZGF0b3IudmFsaWQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleEZyb21Sb3dJZChyb3cuaWQsIHNvdXJjZSk7XHJcblxyXG4gICAgc291cmNlW2luZGV4XSA9IHJvdztcclxuICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xyXG5cclxuICAgIHJvdy5lZGl0aW5nID0gZmFsc2U7XHJcbiAgICByb3cudmFsaWRhdG9yLmRpc2FibGUoKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIHJvdyB3aXRoIHRoZSBpbmRleCBzcGVjaWZpZWQuXHJcbiAgICovXHJcbiAgZGVsZXRlKGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleEZyb21Sb3dJZChpZCwgc291cmNlKTtcclxuXHJcbiAgICBzb3VyY2Uuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIHRoaXMudXBkYXRlUm93SWRzKGluZGV4LCBzb3VyY2UpO1xyXG5cclxuICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xyXG5cclxuICAgIGlmIChpZCAhPSAtMSlcclxuICAgICAgdGhpcy51cGRhdGVEYXRhc291cmNlRnJvbVJvd3Moc291cmNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gKiBHZXQgcm93IGZyb20gdGhlIHRhYmxlLlxyXG4gKiBAcGFyYW0gaWQgSWQgb2YgdGhlIHJvdyB0byByZXRyaWV2ZSwgLTEgcmV0dXJucyB0aGUgY3VycmVudCBuZXcgbGluZS5cclxuICovXHJcbiAgZ2V0Um93KGlkOiBudW1iZXIpOiBUYWJsZUVsZW1lbnQ8VD4ge1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4RnJvbVJvd0lkKGlkLCBzb3VyY2UpO1xyXG5cclxuICAgIHJldHVybiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHNvdXJjZS5sZW5ndGgpID8gc291cmNlW2luZGV4XSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGRhdGFzb3VyY2Ugd2l0aCBhIG5ldyBhcnJheSBvZiBkYXRhLiBJZiB0aGUgYXJyYXkgcmVmZXJlbmNlXHJcbiAgICogaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIG9uZSwgaXQgZG9lc24ndCB0cmlnZ2VyIGFuIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHVwZGF0ZSB0aGUgdGFibGUgZGF0YXNvdXJjZS5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyBTcGVjaWZ5IG9wdGlvbnMgdG8gdXBkYXRlIHRoZSBkYXRhc291cmNlLlxyXG4gICAqIElmIGVtaXRFdmVudCBpcyB0cnVlIGFuZCB0aGUgZGF0YXNvdXJjZSBpcyB1cGRhdGVkLCBpdCBlbWl0cyBhbiBldmVudFxyXG4gICAqIGZyb20gJ2RhdGFzb3VyY2VTdWJqZWN0JyB3aXRoIHRoZSB1cGRhdGVkIGRhdGEuIElmIGZhbHNlLCBpdCBkb2Vzbid0XHJcbiAgICogZW1pdCBhbiBldmVudC4gVHJ1ZSBieSBkZWZhdWx0LlxyXG4gICAqL1xyXG4gIHVwZGF0ZURhdGFzb3VyY2UoZGF0YTogVFtdLCBvcHRpb25zID0geyBlbWl0RXZlbnQ6IHRydWUgfSk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudERhdGEgIT09IGRhdGEpIHtcclxuICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XHJcbiAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dCh0aGlzLmdldFJvd3NGcm9tRGF0YShkYXRhKSlcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmVtaXRFdmVudClcclxuICAgICAgICB0aGlzLmRhdGFzb3VyY2VTdWJqZWN0Lm5leHQoZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHRoZSBleGlzdGFuY2Ugb2YgdGhlIGEgbmV3IHJvdyAobm90IHlldCBzYXZlZCkuXHJcbiAgICogQHBhcmFtIHNvdXJjZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZXhpc3RzTmV3RWxlbWVudChzb3VyY2U6IFRhYmxlRWxlbWVudDxUPltdKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAhKHNvdXJjZS5sZW5ndGggPT0gMCB8fCBzb3VyY2VbdGhpcy5nZXROZXdSb3dJbmRleChzb3VyY2UpXS5pZCA+IC0xKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcG9zc2libGUgaW5kZXggb2YgdGhlIG5ldyByb3cgZGVwZW5kaW5nIG9uIHRoZSBpbnNlcnRpb24gdHlwZS5cclxuICAgKiBJdCBkb2Vzbid0IGltcGx5IHRoYXQgdGhlIG5ldyByb3cgaXMgY3JlYXRlZCwgdGhhdCBtdXN0IGJlIGNoZWNrZWQuXHJcbiAgICogQHBhcmFtIHNvdXJjZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0TmV3Um93SW5kZXgoc291cmNlKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgZWxzZVxyXG4gICAgICByZXR1cm4gc291cmNlLmxlbmd0aCAtIDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSByb3cgaWQgZnJvbSB0aGUgaW5kZXggc3BlY2lmaWVkLiBJdCBkb2VzXHJcbiAgICogbm90IGNvbnNpZGVyIGlmIHRoZSBuZXcgcm93IGlzIHByZXNlbnQgb3Igbm90LCBhc3N1bWVzXHJcbiAgICogdGhhdCBuZXcgcm93IGlzIG5vdCBwcmVzZW50LlxyXG4gICAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgYXJyYXkuXHJcbiAgICogQHBhcmFtIGNvdW50IFF1YW50aXR5IG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICAgKi9cclxuICBwcml2YXRlIGdldFJvd0lkRnJvbUluZGV4KGluZGV4OiBudW1iZXIsIGNvdW50OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cylcclxuICAgICAgcmV0dXJuIGNvdW50IC0gMSAtIGluZGV4O1xyXG4gICAgZWxzZVxyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBmcm9tIHRoZSByb3cgaWQgc3BlY2lmaWVkLlxyXG4gICAqIEl0IHRha2VzIGludG8gYWNjb3VudCBpZiB0aGUgbmV3IHJvdyBleGlzdHMgb3Igbm90LlxyXG4gICAqIEBwYXJhbSBpZFxyXG4gICAqIEBwYXJhbSBzb3VyY2VcclxuICAgKi9cclxuICBwcml2YXRlIGdldEluZGV4RnJvbVJvd0lkKGlkOiBudW1iZXIsIHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiBudW1iZXIge1xyXG4gICAgaWYoaWQgPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZXhpc3RzTmV3RWxlbWVudChzb3VyY2UpID8gdGhpcy5nZXROZXdSb3dJbmRleChzb3VyY2UpIDogLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKVxyXG4gICAgICAgICAgcmV0dXJuIHNvdXJjZS5sZW5ndGggLSAxIC0gaWQ7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgcm93cyBpZHMgaW4gdGhlIGFycmF5IHNwZWNpZmllZCwgc3RhcnRpbmcgaW4gdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAqIHVudGlsIHRoZSBzdGFydC9lbmQgb2YgdGhlIGFycmF5LCBkZXBlbmRpbmcgb24gY29uZmlnLnByZXBlbmROZXdFbGVtZW50c1xyXG4gICAqIGNvbmZpZ3VyYXRpb24uXHJcbiAgICogQHBhcmFtIGluaXRpYWxJbmRleCBJbml0aWFsIGluZGV4IG9mIHNvdXJjZSB0byBiZSB1cGRhdGVkLlxyXG4gICAqIEBwYXJhbSBzb3VyY2UgQXJyYXkgdGhhdCBjb250YWlucyB0aGUgcm93cyB0byBiZSB1cGRhdGVkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdXBkYXRlUm93SWRzKGluaXRpYWxJbmRleDogbnVtYmVyLCBzb3VyY2U6IFRhYmxlRWxlbWVudDxUPltdKTogdm9pZCB7XHJcblxyXG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMgPyAtMSA6IDE7XHJcblxyXG4gICAgZm9yIChsZXQgaW5kZXggPSBpbml0aWFsSW5kZXg7IGluZGV4IDwgc291cmNlLmxlbmd0aCAmJiBpbmRleCA+PSAwOyBpbmRleCArPSBkZWx0YSkge1xyXG4gICAgICBpZiAoc291cmNlW2luZGV4XS5pZCAhPSAtMSlcclxuICAgICAgICBzb3VyY2VbaW5kZXhdLmlkID0gdGhpcy5nZXRSb3dJZEZyb21JbmRleChpbmRleCwgc291cmNlLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgcm93cy5cclxuICAgKiBAcGFyYW0gcm93cyBSb3dzIHRvIGV4dHJhY3QgdGhlIGRhdGEuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXREYXRhRnJvbVJvd3Mocm93czogVGFibGVFbGVtZW50PFQ+W10pOiBUW10ge1xyXG4gICAgcmV0dXJuIHJvd3NcclxuICAgICAgLmZpbHRlcihyb3cgPT4gcm93LmlkICE9IC0xKVxyXG4gICAgICAubWFwPFQ+KChyb3cpID0+IHtcclxuICAgICAgcmV0dXJuIHJvdy5vcmlnaW5hbERhdGEgPyByb3cub3JpZ2luYWxEYXRhIDogcm93LmN1cnJlbnREYXRhO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGRhdGFzb3VyY2Ugd2l0aCB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlIHNwZWNpZmllZCByb3dzLlxyXG4gICAqIEBwYXJhbSByb3dzIFJvd3MgdGhhdCBjb250YWlucyB0aGUgZGF0YXNvdXJjZSdzIG5ldyBkYXRhLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdXBkYXRlRGF0YXNvdXJjZUZyb21Sb3dzKHJvd3M6IFRhYmxlRWxlbWVudDxUPltdKTogdm9pZCB7XHJcbiAgICB0aGlzLmN1cnJlbnREYXRhID0gdGhpcy5nZXREYXRhRnJvbVJvd3Mocm93cyk7XHJcbiAgICB0aGlzLmRhdGFzb3VyY2VTdWJqZWN0Lm5leHQodGhpcy5jdXJyZW50RGF0YSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcm9tIGFuIGFycmF5IG9mIGRhdGEsIGl0IHJldHVybnMgcm93cyBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBkYXRhLlxyXG4gICAqIEBwYXJhbSBhcnJheURhdGEgRGF0YSBmcm9tIHdoaWNoIGNyZWF0ZSB0aGUgcm93cy5cclxuICAgKi9cclxuICBwcml2YXRlIGdldFJvd3NGcm9tRGF0YShhcnJheURhdGE6IFRbXSk6IFRhYmxlRWxlbWVudDxUPltdIHtcclxuICAgIHJldHVybiBhcnJheURhdGEubWFwPFRhYmxlRWxlbWVudDxUPj4oKGRhdGEsIGluZGV4KSA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgVGFibGVFbGVtZW50KHtcclxuICAgICAgICBpZDogdGhpcy5nZXRSb3dJZEZyb21JbmRleChpbmRleCwgYXJyYXlEYXRhLmxlbmd0aCksXHJcbiAgICAgICAgZWRpdGluZzogZmFsc2UsXHJcbiAgICAgICAgY3VycmVudERhdGE6IGRhdGEsXHJcbiAgICAgICAgc291cmNlOiB0aGlzLFxyXG4gICAgICAgIHZhbGlkYXRvcjogdGhpcy52YWxpZGF0b3JTZXJ2aWNlLmdldFJvd1ZhbGlkYXRvcigpLFxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggaWRlbnRpY2FsIHN0cnVjdHVyZSB0aGFuIHRoZSB0YWJsZSBzb3VyY2UgZGF0YS5cclxuICAgKiBJdCB1c2VzIHRoZSBvYmplY3QncyB0eXBlIGNvbnRydWN0b3IgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgY3JlYXRlc1xyXG4gICAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgY29udGFpbmVkIGluIHRoZSBvcmlnaW5hbFxyXG4gICAqIGRhdGFzb3VyY2UgKHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yKS5cclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZU5ld09iamVjdCgpOiBUIHtcclxuICAgIGlmICh0aGlzLmRhdGFDb25zdHJ1Y3RvcilcclxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmRhdGFDb25zdHJ1Y3RvcigpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFLZXlzLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcclxuICAgICAgICBvYmpba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICB9LCB7fSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqIENvbm5lY3QgZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0YWJsZSB0byByZXRyaWV2ZSBvbmUgc3RyZWFtIGNvbnRhaW5pbmdcclxuICAgKiAgdGhlIGRhdGEgdG8gcmVuZGVyLiAqL1xyXG4gIGNvbm5lY3QoKTogT2JzZXJ2YWJsZTxUYWJsZUVsZW1lbnQ8VD5bXT4ge1xyXG4gICAgcmV0dXJuIHRoaXMucm93c1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XHJcbiAgfVxyXG5cclxuICBkaXNjb25uZWN0KCkgeyB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBWYWxpZGF0b3JTZXJ2aWNlIHtcclxuICBhYnN0cmFjdCBnZXRSb3dWYWxpZGF0b3IoKTogRm9ybUdyb3VwO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJGb3JtR3JvdXAiLCJJbmplY3RhYmxlIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJCZWhhdmlvclN1YmplY3QiLCJTdWJqZWN0IiwiRGF0YVNvdXJjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBSUE7OztBQUVBOztRQUFBO1FBcUJFLHNCQUFZLElBQThCO1lBQ3hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBQzdCLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDbEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO29CQUNoQixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUN6QjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO2lCQUMxQjthQUNGO1NBQ0Y7UUF4QkQsc0JBQUkscUNBQVc7OztnQkFBZjs7Z0JBRUUsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNsQixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7aUJBQ3ZFO3FC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